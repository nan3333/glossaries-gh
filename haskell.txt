https://wiki.haskell.org/Category:Glossary

http://dev.stephendiehl.com/fun/001_basics.html

http://learnyouahaskell.com/input-and-output
lyah sequence

function
    inc x   = x+1
    add x y = x+y

    are really shorthand for: 

    inc = \x   -> x+1
    add = \x y -> x+y

Function application
    Example: map function:

        map          :: (a->b) -> [a] -> [b]
        map f  []    =  []
        map f (x:xs) =  f x : map f xs

    Second equation:

        map f (x:xs) =  f x : map f xs

    Function application has higher precedence
    than any infix operator, and thus the
    right-hand side of the second equation
    parses as:

        (f x) : (map f xs)

circular
circularity
    Here is an infinite list of ones:

        ones = 1 : ones

    The definition of ones above is an example
    of a circular list.

    In most circumstances laziness has an
    important impact on efficiency, since an
    implementation can be expected to
    implement the list as a true circular
    structure, thus saving space.

    Another example:

        fib = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]

non-terminating expression
_|_
    Suppose bot is defined by:

        bot = bot

    In other words, bot is a non-terminating
    expression.

    Abstractly, we denote the value of a non-
    terminating expression as _|_ (read
    "bottom").

    Expressions that result in some kind of a
    run-time error, such as 1/0, also have
    this value.

    Such an error is not recoverable: programs
    will not continue past these errors.

    Errors encountered by the I/O system, such
    as an end-of-file error, are recoverable
    and are handled in a different manner.

    (Such an I/O error is really not an error
    at all but rather an exception.

    Much more will be said about exceptions in
    Section 7.)

    See "error function".

error
error function
    Its type is String->a.

    This is a somewhat odd function: From its
    type it looks as if it is returning a
    value of a polymorphic type about which it
    knows nothing, since it never receives a
    value of that type as an argument!

    In fact, there is one value "shared" by
    all types: _|_. Indeed, semantically that
    is exactly what value is always returned
    by error (recall that all errors have
    value _|_). However, we can expect that a
    reasonable implementation will print the
    string argument to error for diagnostic
    purposes. Thus this function is useful
    when we wish to terminate a program when
    something has "gone wrong." For example,
    the actual definition of head taken from
    the Standard Prelude is: 

        head (x:xs) =  x
        head  []    =  error "head{PreludeList}: head []"

    See "_|_".

strict
    A function f is said to be strict if, when
    applied to a nonterminating expression, it
    also fails to terminate.

    In other words, f is strict iff the value
    of f bot is _|_.

    For most programming languages, all
    functions are strict.

    But this is not so in Haskell.

    As a simple example, consider const1, the
    constant 1 function, defined by:

        const1 x = 1

    The value of const1 bot in Haskell is 1.

    Operationally speaking, since const1 does
    not "need" the value of its argument, it
    never attempts to evaluate it, and thus
    never gets caught in a nonterminating
    computation.

    For this reason, non-strict functions are
    also called "lazy functions", and are said
    to evaluate their arguments "lazily", or
    "by need".

fixity declaration
    Can be given for any infix operator or
    constructor (including those made from
    ordinary identifiers, such as `elem`).

    This declaration specifies a precedence
    level from 0 to 9 (with 9 being the
    strongest; normal application is assumed
    to have a precedence level of 10), and
    left-, right-, or non-associativity.

    For example, the fixity declarations for
    ++ and .  are:

        infixr 5 ++
        infixr 9 .

    Both of these specify right-associativity,
    the first with a precedence level of 5,
    the other 9.

    Left associativity is specified via
    infixl, and non-associativity by infix.

    Also, the fixity of more than one operator
    may be specified with the same fixity
    declaration.

    If no fixity declaration is given for a
    particular operator, it defaults to infixl
    9.

    (See ยง4.4.2 for a detailed definition of
    the associativity rules.)

associative
    Associative operators are those that are
    not sensitive of the sequence of
    execution, for example, 5+3+2 will always
    result in 10 whether you execute/solve the
    right part first or the last part.

non-associative
non-associativity
    Non-associative operators are those whose
    result will differ based upon the sequence
    of execution or solving, for example,
    5-3-2 will result in 0 if the left pair is
    executed first and will result in 4 if the
    right part is executed first.
    
    The Non-Associative operators are further
    classified as:
    - left-associative
    - right associative.

left associative
right associative
left-associative
right-associative
    [non-associative]

non-strict
lazy
    ewwlinks +/"Functions are Non-strict" "https://www.haskell.org/tutorial/functions.html"

    Another way of explaining non-strict
    functions is that Haskell computes using
    definitions rather than the assignments
    found in traditional languages. Read a
    declaration such as

        v = 1/0

    as `define v as 1/0' instead of `compute
    1/0 and store the result in v'.  Only if
    the value (definition) of v is needed will
    the division by zero error occur.

    One advantage of the non-strict nature of
    Haskell is that data constructors are
    non-strict, too. This should not be
    surprising, since constructors are really
    just a special kind of function (the
    distinguishing feature being that they can
    be used in pattern matching). For example,
    the constructor for lists, (:), is
    non-strict.

    Non-strict constructors permit the
    definition of (conceptually) infinite data
    structures. Here is an infinite list of
    ones:

        ones = 1 : ones

    Perhaps more interesting is the function
    numsFrom:

        numsFrom n = n : numsFrom (n+1)

    Thus numsFrom n is the infinite list of
    successive integers beginning with n. From
    it we can construct an infinite list of
    squares:

        squares = map (^2) (numsfrom 0)

    See "strict".

state
    Violates referential transparency.

static typing
statically typed
    Haskell is statically typed.

    Typing
        "When types are checked"

    Static
        Types checked before run-time
    Dynamic
        Types checked on the fly, during
        execution

Haskell
    [language]

    A polymorphic lambda calculus with lazy
    evaluation plus algebraic data types and
    type classes.

    This happens to be just the right
    combination of features to allow us to
    write clean, maintainable code that also
    runs fast.

    ewwlinks +/"Standard Haskell: Ergonomics + Performance" "https://serokell.io/blog/why-dependent-haskell"

    Attributes:
    - polymorphism type: parametric

    A distinct construct exists to represent
    side effects, orthogonal to the type of
    functions.

    why?
    - reasoning about code
    - purity
      flows from laziness
    - strong static typing

    ewwlinks +/"Runtime Correctness" "https://github.com/github/semantic/blob/master/docs/why-haskell.md"

Haskell Kernel
    Haskell has adopted many of the convenient
    syntactic structures that have become
    popular in functional programming. In this
    Report, the meaning of such syntactic
    sugar is given by translation into simpler
    constructs. If these translations are
    applied exhaustively, the result is a
    program written in a small subset of
    Haskell that we call the Haskell kernel.

    Although the kernel is not formally
    specified, it is essentially a slightly
    sugared variant of the lambda calculus
    with a straightforward denotational
    semantics. The translation of each
    syntactic structure into the kernel is
    given as the syntax is introduced. This
    modular design facilitates reasoning about
    Haskell programs and provides useful
    guidelines for implementors of the
    language.

    ewwlinks +/"The Haskell Kernel" "https://www.haskell.org/onlinereport/haskell2010/haskellch1.html#x6-110001.2"

type constructor
 vs
data constructor
    Maybe is a type constructor and Nothing
    and Just are data constructors.
    You can construct a data value by applying
    the Just data constructor to a value:

        country = Just "China"

    In the same way, you can construct a type
    by applying the Maybe type constructor to
    a type:

        lookupAge :: DB -> String -> Maybe Int

    Type constructors such as Point and data
    constructors such as Pt are in separate
    namespaces. This allows the same name to
    be used for both a type constructor and
    data constructor, as in the following: 

        data Point a = Point a a

    Data constructors:

        data Tree a = Leaf a | Branch (Tree a) (Tree a) 

        Here we have defined a polymorphic
        binary tree type whose elements are
        either leaf nodes containing a value
        of type a, or internal nodes
        ("branches") containing (recursively)
        two sub-trees.

        When reading data declarations such as
        this, remember again that Tree is a
        type constructor, whereas Branch and
        Leaf are data constructors. Aside from
        establishing a connection between
        these constructors, the above
        declaration is essentially defining
        the following types for Branch and
        Leaf: 

        Branch :: Tree a -> Tree a -> Tree a
        Leaf   :: a -> Tree a

type constuctor
    Examples:
        [] is also a type constructor. Given
        any type t we can "apply" [] to yield
        a new type [t].

        The Haskell syntax allows [] t to be
        written as [t].

        Similarly, -> is a type constructor:
        given two types t and u, t->u is the
        type of functions mapping elements of
        type t to elements of type u.

concrete
concrete type
concrete data type
    Can be introduced with the data construct
    (without parameters), or by specializing a
    Parametrized data type to a specific
    situation.

    For example, Maybe Integer , Bool ,
    [(String,String)] and Tree String are
    concrete data types.

polymorphic type
    Can be thought of as containers for values
    of another type.

    Monad types are polymorphic types.

    They are like containers that are capable
    of holding values of many different types.
    
    So Maybe Int can be thought of as a Maybe
    container holding an Int value (or
    Nothing) and Maybe String would be a Maybe
    container holding a String value (or
    Nothing).
    
    In Haskell, we can also make the type of
    the container polymorphic, so we could
    write "m a" to represent a container of
    some type holding a value of some type!

Continuation Passing Style
CPS
    Continuation passing style is a
    transformation from a normal function and
    a call stack to a direction to send the
    result to the "continuation" without
    returning.

    This means the functions context can be
    cleaned up.

    Delimited continuations are a slight
    variation, where instead of an unbounded
    "rest of the program", the continuation
    has an end point and a value.

    It's essentially a function, and can be
    handled as such.

    There is a purely mechanical method for
    converting all of the lambda calculus
    transforms into CPS form, and this can be
    profitable for compilers based on lambda,
    or related logics, like system F.

continuation monad
    CPS is tedious, though.

    Having to explicitly add a continuation to
    everything is complicated.

    However, there's also a typeclass, or
    concept, that allows you to convert
    regular functions into continuation
    passing style, automatically.

    It's then rather straightforward to
    involve concerns like where work is being
    run for something that wraps up the entire
    work.

    Even being able to switch back and forth
    between contexts.

    That's the continuation monad.

non-deterministic computation
    The kind of computation that, instead of
    producing a single result, might produce
    many.

    https://www.schoolofhaskell.com/school/starting-with-haskell/basics-of-haskell/13-the-list-monad

    A computation returning a non-
    deterministic result of type a is not a
    pure function, but it can be made into one
    by transforming its result type from a to
    a list of a.

    In essence, we create a function that
    returns all possible results at once.

monadic function
    Functions that return a monadic type are
    called monadic functions.

    Each monad provides a mechanism for
    composing such monadic functions.

    As we have seen, the do notation
    simplifies the syntax of composing
    multiple monadic functions.

one-way monads
    Many monads are one-way i.e. you can't get
    values back out of the monad. But y ou may
    implment functions for your monad that do
    this. An example is the IO monad.

    Allow values to enter the monad through
    the return function (and sometimes the
    fail function) and they allow computations
    to be performed within the monad using the
    bind functions >>= and >>, but they do not
    allow values back out of the monad.

    However, List and Maybe, do allow values
    out of the monad. So it is possible to
    write functions which use these monads
    internally but return non-monadic values.

interface
interface class
    They provide functionality to your
    classes.

    Any Type class that wants to check the
    equality of an expression should be a part
    of the EQ Type Class.

    Examples
    - Ord
    - EQ

    Any Type class that wants to be used by
    ">", "<", "<=", ">=", "compare" should be
    a part of the Ord Type Class.

diverge
divergence
    [#mathematics]

    (of a series) increase indefinitely as
    more of its terms are added.

catamorphism
    [#category theory]

    A general abstraction that enables you to
    handle multiple values, for example in
    order to reduce them to a single value.

    The concept of catamorphism denotes the
    unique homomorphism from an initial
    algebra into some other algebra.

    [#functional programming]

    Catamorphisms provide generalizations of
    folds of lists to arbitrary algebraic data
    types, which can be described as initial
    algebras.

    https://youtu.be/LXx-dOmjxg0

    [#category theory]

    The concept of catamorphism denotes the
    unique homomorphism from an initial
    algebra into some other algebra.

    $MYGIT/acmeism/RosettaCodeData/Task/Catamorphism

    Catamorphisms provide generalizations of
    folds of lists to arbitrary algebraic data
    types, which can be described as initial
    algebras.

    [#category theory]

    Deconstructs a data structure with an
    F-algebra for its underlying functor.

    A catamorphism for some F-algebra (X,f) is
    denoted (| f |)F.

    When the functor F can be determined
    unambiguously, it is usually written (|ฯ|)
    or cata ฯ.

    Due to this choice of notation, a
    catamorphism is sometimes called a banana
    and the (|.|) notation is sometimes
    referred to as banana brackets.

    Examples:
        $MYGIT/acmeism/RosettaCodeData/Task/Catamorphism/C++/catamorphism.cpp

    The unique homomorphism from an initial
    algebra into some other algebra.

    In FP, catamorphisms provide
    generalizations of folds of lists to
    arbitrary algebraic data types, which can
    be described as initial algebras.

    The dual concept is that of anamorphism
    that generalize unfolds.

    A hylomorphism is the composition of an
    anamorphism followed by a catamorphism.

anamorphism
    A function that generates a sequence by
    repeated application of the function to
    its previous result.

    You begin with some value A and apply a
    function f to it to get B.

    Then you apply f to B to get C, and so on
    until some terminating condition is
    reached.

ascription
type ascription
    > :t (+)
    (+) :: Num a => a -> a -> a

    You can read the type for (+) as saying
    "(+) takes two Ints or two Floats or two
    Doubles or two values of any other numeric
    type and returns another number of the
    same type as the arguments". Haskell
    automatically infers the specific types
    based on how the expressions are used. But
    we can also explicitly tell Haskell which
    types we want using type ascription.

    > :t (4 :: Int) + (5 :: Int)

section
operator section
section of an infix operator
    [#haskell]

    Convert infix operator into a functional
    value.

    The partial application of an
    infix operator.

    This is the opposite of backquote notation
    (i.e. making a functional value into an
    operator).

    For example:

        (x+)  =  \y -> x+y
        (+y)  =  \x -> x+y
        (+)   =  \x y -> x+y

    The parentheses are mandatory.

    Handy when passing an infix operator as an
    argument to a function, as in:

        map (+) [1,2,3]

    A special syntax for partial application
    on infix operators.

    https://wiki.haskell.org/Section_of_an_infix_operator

    \x -> 2 ^ x
        (2^) (left section) is equivalent to (^) 2,
        or more verbosely \x -> 2 ^ x

    \x -> x ^ 2
        (^2) (right section) is equivalent to flip (^) 2,
        or more verbosely \x -> x ^ 2

    https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions#postfixoperators

existential types
    [#haskell]

    ifl existential type haskell

    Normally when creating a new type using
    type, newtype, data, etc., every type
    variable that appears on the right-hand
    side must also appear on the left-hand
    side.

    Existential types are a way of turning
    this off.

generics
    [#haskell]

type applications
    [#haskell]

TypeInType
    [#haskell]
    [WIP language extension]

    Modern type-level programming.

    Covers a wealth of features, all with the
    aim of creating a dependently typed
    Haskell.

language extensions
    [#haskell]

    cd $MYGIT/facebook/duckling/Duckling/; grep -HnR "# LANGUAGE" . | scrape "LANGUAGE [^ ]+" | uniqnosort
    sed -n "s/.*LANGUAGE \(.*\)/\1\n    [haskell language extension]\n/ip"

PostfixOperators
    [haskell language extension]

    ewwlinks +/"PostfixOperators" "https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions"

    Normally, when you write, for example:

        (4 !)

    it expands into:

        \x -> 4 ! x

    or, equivalently:

        \x -> (!) 4 x

    PostfixOperators instead expands this left section into:

        (!) 4

Data.Typeable and Data.Data
    ewwlinks +/"Typeable and Data in Haskell" "https://chrisdone.com/posts/data-typeable/"

    Rather mysterious.

    Starting out as a Haskell newbie you see
    them once in a while and wonder what use
    they are.

    Their Haddock pages are pretty opaque and
    scary in places.

    Here's a quick rundown I thought I'd write
    to get people up to speed nice and quick
    so that they can start using it.

    It's really rather beautiful as a way to
    do generic programming in Haskell.

    The general approach is that you don't
    know what data types are being given to
    you, but you want to work upon them almost
    as if you did.

    The technique is simple when broken down.

DeriveDataTypeable
    [haskell language extension]

    Now you can derive instances of both
    Data.Typeable and Data.Data:

        data X = X
          deriving (Data,Typeable)

    Now we can start doing generic operations
    upon X.

MultiParamTypeClasses
    [haskell language extension]

DeriveAnyClass
    [haskell language extension]

DeriveGeneric
    [haskell language extension]

NoRebindableSyntax
    [haskell language extension]

TypeFamilies
    [haskell language extension]

OverloadedStrings
    [haskell language extension]

GADTs
    [haskell language extension]

LambdaCase
    [haskell language extension]

tuple constructor
    [#haskell]

    Example:

        (,,,,) 1 "hello" 6.5 (Just ()) [5, 5, 6, 7]

    See:
        vim +/"TupleSections" "$HOME/notes/glossary.txt"

TupleSections
    [haskell language extension]

    ewwlinks +/"TupleSections" "https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions"

    Allows you to:
    - omit values from the tuple syntax,
      unifying the standard tuple sugar with
      the tuple constructor syntax to form one
      generalized syntax for tuples.

    Normally, tuples are constructed with the
    standard tuple sugar, which looks like
    this:

        (1, "hello", 6.5, Just (), [5, 5, 6, 7])

    This could be considered shorthand for the
    following explicit tuple constructor use:

        (,,,,) 1 "hello" 6.5 (Just ()) [5, 5, 6, 7]

    However, the explicit tuple constructor
    (,,,,) could just as easily be considered
    section sugar for tuples, expanding to:

        \v w x y z -> (v, w, x, y, z)

    Looking at it this way allows us to ask,
    "Why can't we partially section a tuple?
    After all, (+) is valid, (,) is valid, and
    (1 +) is valid, but (1,) is not valid. The
    TupleSections extension fixes this
    oversight.

    With TupleSections you can now write, for
    example:

        (1, "hello",, Just (),)

    and have it mean the same as

        \x y -> (1, "hello", x, Just (), y)

NamedFieldPuns
    [haskell language extension]

    ewwlinks +/"Record puns are enabled by the flag -XNamedFieldPuns." "https://downloads.haskell.org/~ghc/7.6.2/docs/html/users_guide/syntax-extns.html"

    When using records, it is common to write
    a pattern that binds a variable with the
    same name as a record field, such as:

        data C = C {a :: Int}
        f (C {a = a}) = a

    Record punning permits the variable name
    to be elided, so one can simply write

        f (C {a}) = a

RecordWildCards
    [haskell language extension]

AllowAmbiguousTypes
    [haskell language extension]

ExistentialQuantification
    [haskell language extension]

FlexibleContexts
    [haskell language extension]

FlexibleInstances
    [haskell language extension]

RankNTypes
    [haskell language extension]

ScopedTypeVariables
    [haskell language extension]

StandaloneDeriving
    [haskell language extension]

TypeOperators
    [haskell language extension]

BangPatterns
    [haskell language extension]

Math
    Purely functional.

    vimlinks +/"Mathematics is a purely functional language. " "http://matt.might.net/articles/discrete-math-and-code/"

package
    [#cabal]

    Has:
    - A name and version
    - 0 or 1 libraries
    - 0 or more executables
    - A cabal file (or, as mentioned above, an
      hpack package.yaml that generates a
      cabal file)
    - And a bunch more

cabal-install vs stack
    https://stackoverflow.com/questions/30913145/what-is-the-difference-between-cabal-and-stack

    cabal-install and stack are frontends to
    Cabal.

    Both tools make it possible to build
    Haskell projects whose sets of
    dependencies might conflict with each
    other within the confines of a single
    system.

    The key difference between them lies in
    how they address this goal.

Stack
    [build tool]

    Works on top of the Cabal build system.

project
    [#stack]

    Has:
    - A resolver, which tells it about a
      snapshot (more on this later)
    - Extra dependencies on top of the
      snapshot
    - 0 or more local Cabal packages
    - Flag and GHC options configurations
    - And a bunch more Stack configuration

value constructor
tag
    data RGB
      = MkRGB Int Int Int
    {-
          ^    ^   ^   ^
          |    |   |   |
          |    |   |   +- This is the blue component
          |    |   |
          |    |   +----- This is the green component
          |    |
          |    +--------- This is the red component
          |
          +------------- This is called the value constructor, or "tag"
    -}

magenta :: RGB
magenta = MkRGB 255 0 255

return
    [Function in Haskell]

    fathersMaternalGrandmother :: Sheep -> Maybe Sheep
    fathersMaternalGrandmother s = (return s) >>= father >>= mother >>= mother

    Return turns the sheep into a Maybe sheep.

    Has little to do with the return keyword
    in imperative programming languages.

    It's just an ordinary function with an
    ordinary type signature:

    return :: Monad m => a -> m a

    Basically, return takes any old value and
    "lifts" it into a monad. It's a little
    clearer what this function does when you
    replace the m with a concrete type, like
    Maybe:

    return :: a -> Maybe a

dependent type
    [type]

    A type whose definition depends on a
    value.

    It is an overlapping feature of type
    theory and type systems.

Eq
    [typeclass]

    The Int type is an instance of the Eq
    typeclass because the Eq typeclass defines
    behavior for stuff that can be equated.

    And because integers can be equated, Int
    is a part of the Eq typeclass.

type variable
    Example:
        Given the type:
            a -> a -> a
        'a' is a type variable.

    ewwlinks +/"Type Variables" "https://cs.lmu.edu/~ray/notes/introhaskell/"

    We know [Char] and [Float] are two
    different types. So how do we speak about,
    or write functions that work on, lists of
    ANY type? Or tuples of any size, or any
    component type?

    Answer: type variables.

    Type variables come in lowercase.

typeclass method
type class method
    ewwlinks +/"type class method" "https://www.schoolofhaskell.com/school/starting-with-haskell/introduction-to-haskell/5-type-classes"

list comprehension
    [x*2 | x = 12]

    The part before the pipe is called the
    output function.

    ewwlinks +/"I'm a list comprehension" "http://learnyouahaskell.com/starting-out#im-a-list-comprehension"

$
    readsubs +/"that dollar thing" "[[https://www.youtube.com/watch?v=SMj-n2f7wYY][Adam McCullough - Monad Transformers for the Easily Confused - C 2018 - YouTube]]"

    These type signatures are similar:
        med <(ghcit '($ 5)') <(ghcit '(+ 10)')

value constructor
    [function]

    Returns a value of a data type.

    Example:
        data Shape = Circle Float Float Float | Rectangle Float Float Float Float

        Circle and Rectangle are the value
        constructors.

        They are just functions.

        ewwlinks +/":t Circle" "http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass"

        ghci> :t Circle
        Circle :: Float -> Float -> Float -> Shape

applicative
applicative functor
    [Type class]

    Something that specifies how to map a
    function onto instances of itself
    (instances that wrap basic values but also
    instances that wrap functions).

    An intermediate structure between functors
    and monads. Applicative functors are the
    programming equivalent of lax monoidal
    functors with tensorial strength in
    category theory.

    Applicatives extend functors in that they
    allow us to wrap functions, rather than
    basic values.

    So you can have a Just (+1).

    tidbits.
    - <*>
      app, apply, spaceship

      The operation of applicative.

      ghcit "(<*>)"

    - The applicative of lists
      See note under "pure".

    - Interchange

    Applicative, the class for applicative
    functors.

    Like monads, applicative functors are
    functors with extra laws and operations.

    Applicative is a widely used class
    with a wealth of applications. It enables
    the eponymous applicative style, a
    convenient way of structuring functorial
    computations, and also provides means to
    express a number of important patterns.

    vim +/"instance Applicative ErrorOr where" "$MYGIT/google/haskell-trainings/haskell_102/codelab/Game.hs"

    http://www.staff.city.ac.uk/~ross/papers/Applicative.html

    Example (of an applicative functor)
        replicateM :: Applicative m => Int -> m a -> m [a]
        base Control.Monad
        replicateM n act performs the action n times, gathering the results.

    #haskell
        00:38 < libertyprime> im looking at the hackage documentation for replicateM. it seems the 4.7 version was easier to understand. why would monad have been changed to
                              applicative? what are the benefits?
        00:38 < libertyprime> http://hackage.haskell.org/package/base-4.7.0.0/docs/src/Control-Monad.html#replicateM
        00:38 < libertyprime> http://hackage.haskell.org/package/base-4.12.0.0/docs/src/Control.Monad.html#replicateM
        00:38 < ski> (in Twelf you're write the same thing, except prefixing the first clause with `sum/zero : ', and the second clause with `sum/succ : '. data type
                     definitions and predicate definitions are the same thing, in Twelf)
        00:38 < Ariakenom> I suppose sleep :: DiffTime -> IO () would be most correct
        00:39 < dminuoso> libertyprime: It admits more instances.
        00:39 < ski> of course, you don't get any automatic proof search with such a data type, in Haskell
        00:39 < dminuoso> libertyprime: There are some things that are Applicative but not Monad. The reason you had a Monad constraint was because it came before Applicative
                          was a thing.
        00:40 < dminuoso> libertyprime: Since the introduction of Applicative a lot of code could be relaxed from requiring Monad to Applicative.
        00:56 < dminuoso> libertyprime: https://gitlab.haskell.org/ghc/ghc/issues/10168 this is the ticket
        00:57 < libertyprime> mawesome. thanks guys
        00:57 < dminuoso> libertyprime: It also describes the reason why the implication is different. :)
        00:57 < dminuoso> *implementation

    Example
        ewwlinks +/"sequence :: (Applicative f) => \[f a\] -> f \[a\]" "http://derekwyatt.org/2012/01/25/haskell-sequence-over-functions-explained/"

<*>
splat
applicative
applicative function
applicative operator
    [operator]

    https://youtu.be/CNOff5LPKQI?t=103

    The applicative operation.

    This is the thing that applicative does.

    readsubs +/"splat" "[[https://www.youtube.com/watch?v=SMj-n2f7wYY][Adam McCullough - Monad Transformers for the Easily Confused - C 2018 - YouTube]]"

    Unlike like how functors have the function
    named "fmap" which does the same thing as
    the infix <$>, applicatives don't have a
    name for the applicative operator <*>.

interchange
    [#applicative]

    $NOTES/ws/haskell/tidbits/interchange.org

    Evaluation order doesn't matter.

    Reason/intuition:
        Even if your functions have effects
        for doing side effect key things order
        of evaluation shouldn't matter.

        https://wiki.haskell.org/Typeclassopedia#Laws

        If this wasn't the case then debugging
        haskell code would be a nightmare.

pure
    [#applicative]
    [function]

    ghciol ":i pure" | vs

    A function that lifts a function into the
    context that applicative is working in.

    Example:
        So, if you are working in the
        applicative of lists, "pure id" will
        give you a list with one value in it
        called id.

        pure id <*> v = v -- identity

    readsubs +/"the context that applicative" "[[https://www.youtube.com/watch?v=SMj-n2f7wYY][Adam McCullough - Monad Transformers for the Easily Confused - C 2018 - YouTube]]"

    When implementing pure for an instance of
    Applicative, implement the simplest case.
        https://youtu.be/CNOff5LPKQI?t=825

bitwise (flags)
    and
        (.&.) :: a -> a -> a infixl 7
    or
        (.|.) :: a -> a -> a infixl 5
    xor
        xor :: a -> a -> a infixl 6
    reverse all bits
        complement :: a -> a

ersatz
    [package]

    http://hackage.haskell.org/package/ersatz

    A monad for expressing SAT or QSAT
    problems using observable sharing.

    Uses 'minisat'.

language extensions
    https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions

    From regular source code:
        {-# LANGUAGE PackageImports #-}

        import "regex-pcre" Text.Regex.PCRE

    From ghci
        :set -XPackageImports

        import "regex-pcre" Text.Regex.PCRE

infixl
infixr
    https://stackoverflow.com/questions/27770118/how-does-the-infix-work

    ewwlinks +/"(|>) :: Seq a -> a -> Seq a infixl 5" "https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Sequence.html#v:-124--62-"

    The r and l refer to the associativity,
    the number you specify refers to the
    operator precedence.

    When you don't specify the associativity
    you get an operator that can be associated
    only by explicit parenthesis or when the
    associativity is non-ambiguous.

    https://wiki.haskell.org/Keywords#infixr

    Examples:
    - infixl 5
    - infixr 5

()
unit
    The empty tuple.

I/O action
    Something that, when performed, will carry
    out an action with a side-effect (that's
    usually either reading from the input or
    printing stuff to the screen) and will
    also contain some kind of return value
    inside it.

Prelude print :: Show a => a -> IO ()
Prelude putStrLn :: String -> IO ()
    Printing a string to the terminal doesn't
    really have any kind of meaningful return
    value, so a dummy value of () is used.

        >:t print $ "emp: "
        print $ "emp: " :: IO ()
        >:t putStrLn $ "emp: "
        putStrLn $ "emp: " :: IO ()

tails
    >tails "klsjdf"
    ["klsjdf","lsjdf","sjdf","jdf","df","f",""]

infix operators
    isPrefixOf "Hello" "Hello World!"
    "Hello" `isPrefixOf` "Hello World!"

    These are equivalent.

isPrefixOf
    ewwlinks +/"isPrefixOf :: Eq a => \[a\] -> \[a\] -> Bool Source #" "http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List.html#v:isPrefixOf"

    Works on a string.

    import Data.List

    include :: String -> String -> Bool
    include xs ys = or . map (isPrefixOf ys) . tails $ xs

    >isPrefixOf "aadvark" "a"
    False
    >isPrefixOf "a" "aadvark"
    True

    >"Hello" `isPrefixOf` "Hello World!"
    True
    >"Hello" `isPrefixOf` "Wello Horld!"
    False

getCurrentDirectory
    import System.Directory
    getCurrentDirectory

.lhs extension
literate formatting
    Source code of a program written in
    Haskell, a functional programming
    language, with literate formatting;
    similar to a standard Haskell Script (.HS
    file), but includes commentary, where only
    lines starting with ">" are considered to
    be program code.

    Example:
    $MYGIT/bollu/teleport/app/Main.lhs

methods
    $MYGIT/lotz84/haskellbyexample/ex/methods.md.hs

Identity
    import Data.Functor.Identity
    Identity 5

sum type
    [#haskell]
    [constructor]

    An alternation of types (e.g. Fruit =
    Apple or Orange).

    Consists of multiple options of type
    constructors under the same type.

    The two cases can be used at all locations
    the type is specified, and are
    discriminated using pattern matching.

    ewwlinks +/"data Sum = A Int | B Bool" "http://dev.stephendiehl.com/fun/001_basics.html"

    "sum" is alternation (A | B, meaning A or B but not both)

    Example:

        data Bool = False | True

    ewwlinks +/"In Haskell, the simplest sum type is the Bool type:" "https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/sum-types"

product type
    [#haskell]
    [constructor]

    Combines multiple fields into the same type.

    ewwlinks +/"data Prod = Prod Int Bool" "http://dev.stephendiehl.com/fun/001_basics.html"

    "product" is combination (A B, meaning A and B together)

constructor
    [AlDT]

    2 types:
    - sum
    - product

    Sums and products can be repeatedly
    combined into an arbitrarily large
    structures.

    Examples:
    - data Pair = P Int Double
      A pair of numbers, an Int and a Double
      together.

      The tag P is used (in constructors and
      pattern matching) to combine the contained
      values into a single structure that can be
      assigned to a variable.

    - data Pair = I Int | D Double
      Just one number, either an Int or else a
      Double.

      In this case, the tags I and D are used
      (in constructors and pattern matching) to
      distinguish between the two alternatives.

    - data T1 = A Int Int | B Bool Bool
      Sums and products can be combined.

braces
{}
    Syntax for records.

selector
    A function generated by a record.

    Extracts the value of a specific field
    from a record.

record
    [product type]

    Uses braces.

    In addition to generating code for the
    constructors, generates a set of functions
    known as selectors which extract the
    values of a specific field from the
    record.

    ewwlinks +/"data Prod = Prod { a :: Int , b :: Bool" "http://dev.stephendiehl.com/fun/001_basics.html"

        data Prod = Prod { a :: Int , b :: Bool }

        :t a
        -- a :: Prod -> Int
        :t b
        -- b :: Prod -> Bool

iterate
    ewwlinks +/"iterate :: (a -> a) -> a -> \[a\] Source #" "http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-OldList.html#v:iterate"

    iterate f x returns an infinite list of repeated applications of f to x:

        iterate :: (a -> a) -> a -> [a]

function application
    Putting a space between two things is
    simply function application.

    The space is sort of like an operator and
    it has the highest precedence.

pattern matching
one-way matching
    Specifying patterns to which some data
    should conform and then checking to see if
    it does and deconstructing the data
    according to those patterns.

    vim +/"pattern matching" "$HOME/notes/ws/haskell/remember.org"

    Pattern matching can also be used on
    tuples.

    Without pattern matching:
         -- the identifier 'a' in the type
         -- definition is separate from the 'a'
         -- in the definition

        addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)
        addVectors a b = (fst a + fst b, snd a + snd b)

    With pattern matching:

        addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)
        addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)

    Pattern matching in Haskell is different
    from that found in logic programming
    languages such as Prolog; in particular,
    it can be viewed as "one-way" matching,
    whereas Prolog allows "two-way" matching
    (via unification), along with implicit
    backtracking in its evaluation mechanism:
        zip (x:xs) (y:ys)       = (x,y) : zip xs ys
        -- Here, 'zip xs ys' is pattern
        -- matched after the former
        zip  xs     ys          = []

    Examples of pattern matching:
        fold :: (a -> a -> a) -> [a] -> a
        fold f [] = error "blah"
        fold f [x] = x
        fold f (x:xs) = f x (fold f x5)

        -- pattern matching
        -- ----------------
        -- fold f [a1, a2, a3, a4]
        -- f a1 (fold f [a2, a3, a4])        -- fold f (x:xs) = f x (fold f x5)
        -- f a1 (f a2 (fold f [a3, a41))     -- fold f (x:xs) = f x (fold f x5)
        -- f a1 (f a2 (f a3 (fold f [a4])))  -- fold f (x:xs) = f x (fold f x5)

    Indeed, matching is permitted using the
    constructors of any type, user-defined or
    not. This includes tuples, strings,
    numbers, characters, etc. For example,
    here's a contrived function that matches
    against a tuple of "constants:" 

        contrived :: ([a], Char, (Int, Float), String, Bool) -> Bool
        contrived    ([],  'b',  (1,   2.0),   "hi",   True) = False

    This example also demonstrates that
    nesting of patterns is permitted (to
    arbitrary depth).

        -- f a1 (f a2 (f a3 a4))             -- fold f [x] = x

    Technically speaking, formal parameters
    (The Report calls these variables.) are
    also patterns---it's just that they never
    fail to match a value.
    
    As a "side effect" of the successful
    match, the formal parameter is bound to
    the value it is being matched against.
    
    For this reason patterns in any one
    equation are not allowed to have more than
    one occurrence of the same formal
    parameter (a property called linearity
    ยง3.17, ยง3.3, ยง4.4.3).

formal parameter
    Example:
        addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)
        addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)

        -- The formal parameters of the
        -- pattern matching are x1, y1, x2 and
        -- y2.

refutable
irrefutable
    [pattern]

    Patterns such as formal parameters that
    never fail to match are said to be
    irrefutable, in contrast to refutable
    patterns which may fail to match.
    
    The pattern used in the contrived example
    above is refutable.
    
    There are three other kinds of irrefutable
    patterns, two of which we will introduce
    now (the other we will delay until Section
    4.4).

patterns
    A way of making sure a value conforms to some form and
    deconstructing it.

    http://learnyouahaskell.com/syntax-in-functions

guards
    A way of testing whether some property of a value (or several of
    them) are true or false.

    http://learnyouahaskell.com/syntax-in-functions#guards-guards

Monoid
    [#haskell]
    [typeclass]

    https://wiki.haskell.org/Monoid

    A class for types which have a single most
    natural operation for combining values,
    together with a value which doesn't do
    anything when you combine it with others
    (this is called the identity element).

    It is closely related to the Foldable
    class, and indeed you can think of a
    Monoid instance declaration for a type m
    as precisely what you need in order to
    fold up a list of values of m.

    Has:
    - an appending operation <> or mappend
    - an identity element, mempty

    Can be made a Semigroup with just instance
    Semigroup MyMonoid.

    Practical explanation:
        If you have a float and you convert
        that float into a Builder and Builder
        is a monoid, that means you can
        combine those Builders into a single
        Builder (because Builder is a monoid).

        Being a Monoid makes something
        combinable.

        https://youtu.be/FYTZkE5BZ-0?t=202

        You use fold to combine them into a
        single thing.

        In the example, he folded a
        [Builder] into a Builder.

semigroup
    http://hackage.haskell.org/package/semigroups

    Has:
    - an append <>

    Does not require:
    - mempty element.

    An algebraic structure consisting of a set
    together with an associative binary
    operation.

    Generalizes a monoid in that there might
    not exist an identity element.

    Originally,
        Also generalized a group to a type
        where every element did not have to
        have an inverse, thus the name
        semigroup.

group
    A monoid with all inverses.

Typeclass
    A class of a class.

    Num contains Integer, Double, Int, Float.

Programming with effects
Programming with monads
Programming with monadic things

ghc-mod
    A backend program to enrich Haskell
    programming in editors. It strives to
    offer most of the features one has come to
    expect from modern IDEs in any editor.

Hackage
    The place where you find packages to
    install using Cabal.

    Any package installable with cabal is
    installable with stack. This is because
    stack uses cabal.

        cabal install language-bash
        stack install language-bash

stack
    Stack uses cabal.

        cabal install language-bash
        stack install language-bash

stack vs cabal
    http://www.scs.stanford.edu/16wi-cs240h/labs/stack.html

monad
monad functor
    [type class]

    Something that specifies how to map a
    function onto instances of itself
    (instances that wrap basic values but also
    instances that wrap functions), but also
    coerces both wrapped and unwrapped values
    into wrapped.

    Like applicative functors, monads are
    functors with extra laws and operations.

    - >>=
      bind

    vim +/"instance Monad ErrorOr where" "$MYGIT/google/haskell-trainings/haskell_102/codelab/Game.hs"

    The standard Monad class definition in
    Haskell looks something like this:

    class Monad m where
        (>>=)  :: m a -> (a -> m b) -> m b
        return :: a -> m a

    return takes a value and embeds it in the monad.

        return :: a -> m a

    bind is a function that combines a monad
    instance m a with a computation that
    produces another monad instance m b from
    a's to produce a new monad instance m b

        (>>=) :: m a -> (a -> m b) -> m b

    A monad is a type constructor, a function
    called return, and a combinator function
    called bind or >>=. These three elements
    work together to encapsulate a strategy
    for combining computations to produce more
    complex computations.

    A monad is used for getting imperative
    behaviour out of functional programs.

    Operations that have side effets i.e.
    - IO
    - Error handling
    - Failure at runtime
    - Changing state

    Non-deterministic operations

    Monads allow the computations to be
    isolated from the side effects and
    non-determinism.

    Examples of common monads:
    - Maybe
      Representing failure.
    - List
      Nondeterminism. Represents carrying
      multiple values.
    - State
      State.
    - Reader
      Read-only environment.
    - IO
      I/O.
    - continuations
    - transducers
    - exceptions
    - logic programming

    Monads are not composable.

    See "monad transformer".

The three fundamental laws of monads
    The concept of a monad comes from a branch
    of mathematics called category theory.
    While it is not necessary to know category
    theory to create and use monads, we do
    need to obey a small bit of mathematical
    formalism. To create a monad, it is not
    enough just to declare a Haskell instance
    of the Monad class with the correct type
    signatures. To be a proper monad, the
    return and >>= functions must work
    together according to three laws:

        1 (return x) >>= f ==== f x
        2 m >>= return ==== m
        3 (m >>= f) >>= g ==== m >>= (\x -> f x >>= g)

    The first law requires that return is a
    left-identity with respect to >>=. The
    second law requires that return is a
    right-identity with respect to >>=. The
    third law is a kind of associativity law
    for >>=. Obeying the three laws ensures
    that the semantics of the do-notation
    using the monad will be consistent.

    Any type constructor with return and bind
    operators that satisfy the three monad
    laws is a monad. In Haskell, the compiler
    does not check that the laws hold for
    every instance of the Monad class. It is
    up to the programmer to ensure that any
    Monad instance they create satisfies the
    monad laws.

monad transformer
    https://wiki.haskell.org/Monad_Transformers_Explained

    You have an innermost monad (usually
    Identity or IO but you can use any monad).

    You then wrap monad transformers around
    this monad to make bigger, better monads.

    https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf

    It is possible to create custom monads
    simply by composing the necessary monad
    transformers. For example, if you need a
    monad with state and error handling, just
    take the StateT and ErrorT monad
    transformers and combine them.

    Concrete example
    - Suppose I was writing a server:
      Each client handling thread must be of
      type IO ()

      That's because forkIO :: IO () -> IO
      ThreadID).

    Monads are not composable.

    This poses a problem, since composition is
    one of the foremost patterns in functional
    programming.

    However, many alternatives have been
    devised.

    One of the most common is the monad
    transformer.

    Monad transformers allow developers to
    compose the effects of different monads,
    even if the monads themselves are not the
    same.

    An example is writing a do-statement that
    can:
    - abort computation (ExceptT),
    - thread state (StateT), and
    - connect to a database
      (via a Haskell library such as
      persistence or esqueleto).

    The transformers package is used by over
    2,500 packages on Stackage.

    But using monad transformers is a
    challenge for many, even if they are
    already writing useful, effectful,
    production Haskell.

Functor
    [Type class]

    https://www.youtube.com/watch?v=xCut-QT2cpI&ab_channel=KracX

    Example
    - <$>
      eff-map

    Something that specifies how to map a
    function onto instances of itself
    (instances that wrap basic values).

    Things that can be mapped over, like
    lists, Maybes, trees, and such.

    In Haskell, they're described by the
    typeclass Functor, which has only one
    typeclass method, namely fmap, which has
    the type:
        fmap :: (a -> b) -> f a -> f b

        It says:
            Give me a function that takes an a
            and returns a b and a box with an
            a (or several of them) inside it
            and I'll give you a box with a b
            (or several of them) inside it.

    It kind of applies the function to the
    element inside the box.

    vim +/"instance Functor ErrorOr where" "$MYGIT/google/haskell-trainings/haskell_102/codelab/Game.hs"

Tokenizer
    token :: String -> [String]
    token = undefined

    A tokenizer is something that takes a
    string and returns the list of tokens.

    token :: String -> [(Int, String)]
    If you change the type to this, then the
    tokens are indexed and you can see the
    positions of the tokens in the string.

    token :: [(Int,Char)] -> [(Int, String)]
    You could then index the input to the
    tokenizer.

    Now this looks like a generic type.

GHC's Generics mechanism
GHC.Generics
    Support for datatype-generic programming
    through two features, enabled with two
    flags:
    - DeriveGeneric
    - DefaultSignatures

    We show how this all works in this page,
    starting with a detailed example.

prelude
    A module that contains a small set of
    standard definitions and is included
    automatically into all Haskell modules.

\x
Nameless function 'x'
    Example,
        (\x -> x + 1) 4

        Returns: 5 :: Integer

<-
    x <- action runs the IO action, gets its
    result, and binds it to x.

getLine
    Reads a string into a variable, inside a
    do.

    do
      path <- getLine


    getLine is an I/O action that contains a
    result type of String.

        ghci> :t getLine
        getLine :: IO String
        luggage

    It will wait for the user to input
    something at the terminal and then that
    something will be represented as a string.

    perform the I/O action getLine and then
    bind its result value to name:

        name <- getLine

    getLine has a type of IO String, so name
    will have a type of String.

    Once it's fetched that data for you, the
    only way to open the box and get the data
    inside it is to use the <- construct.

    Caveat:
        If we're taking data out of an I/O
        action, we can only take it out when
        we're inside another I/O action.

    We temporarily un-taint the data inside an
    I/O action when we bind it to a name, so
    that it can be used again in pure code.

=
    let x = action defines x to be equivalent
    to action, but does not run anything.
    Later on, you can use y <- x meaning y <-
    action.

liftA
    hoogle liftA | vs

    It's an applicative functor.

    Transform a function into a corresponding
    function within another (usually more
    general) setting.

MonadRandom
    https://hackage.haskell.org/package/MonadRandom-0.1.3/docs/Control-Monad-Random.htm

    A random number generation monad.

referential transparency
    One value is as good as another in Haskell
    if it represents the same thing.

ghcid
    Very low feature GHCi based IDE

    readsubs +/"it monitors all of the files in the" "[[https://youtu.be/5p2Aq3bRuL0][My Haskell Setup - YouTube]]"

Advanced Haskell
    https://en.wikibooks.org/wiki/Haskell/Monoids
    https://en.wikibooks.org/wiki/Haskell/Applicative_functors
    https://en.wikibooks.org/wiki/Haskell/Foldable
    https://en.wikibooks.org/wiki/Haskell/Traversable
    https://en.wikibooks.org/wiki/Haskell/Arrow_tutorial
    https://en.wikibooks.org/wiki/Haskell/Understanding_arrows
    https://en.wikibooks.org/wiki/Help:Development_stages
    https://en.wikibooks.org/wiki/Haskell/Zippers
    https://en.wikibooks.org/wiki/Haskell/Lenses_and_functional_references
    Co-monads
    MonadFix
    Effectful Streaming
    https://en.wikibooks.org/wiki/Haskell/Mutable_objects
    https://en.wikibooks.org/wiki/Haskell/Concurrency
    Template Haskell
    Type Families

lens
    [library]

    [[https://www.youtube.com/watch?v=7fbziKgQjnw][A Brief Introduction of the Haskell Lens Library - YouTube]]

    Lenses are used here and in a lot of other
    places.

    https://rosettacode.org/wiki/CSV_data_manipulation#Haskell

    Lenses are really great for working with
    records and nested records.

++
(++)
    [operator]

    Requires both its parameters to be lists
    over the same type.

    This is invalid:
        nameTag = "Hello, my name is " ++ getLine

do
    Use do syntax to glue together several I/O actions into one.

        main = do
            putStrLn "Hello, what's your name?"
            name <- getLine
            putStrLn ("Hey " ++ name ++ ", you rock!")

    Each of these steps is an I/O action.

    By putting them together with do syntax,
    we glued them into one I/O action.

    The action that we got has a type of IO
    (), because that's the type of the last
    I/O action inside.

    redundant binds
        ewwlinks +/"Except for the last line" "http://learnyouahaskell.com/input-and-output"

        Except for the last line, every line
        in a do block that doesn't bind can
        also be written with a bind

let
    form:
        let <bindings> in <expression>

    ewwlinks +/"Let it be" "http://learnyouahaskell.com/syntax-in-functions"

        (let a = 100; b = 200; c = 300 in a*b*c, let foo="Hey "; bar = "there!" in foo ++ bar)

    In list comprehensions, the in part isn't
    needed.

    You can also put let bindings inside list
    comprehensions.

        calcBmis :: (RealFloat a) => [(a, a)] -> [a]
        calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2]

    'let' allows you to combine the
    readability of a 'where' clause with the
    power of a lambda function.

let vs where
    ewwlinks +/"Very similar to where bindings are let bindings" "http://learnyouahaskell.com/syntax-in-functions"

    The difference is that let bindings are
    expressions themselves. where bindings are
    just syntactic constructs.

    where:

        where bmi weight height = weight / height ^ 2

    let:

        let sideArea = 2 * pi * r * h
        topArea = pi * r ^2
        in  sideArea + 2 * topArea

Case expressions
    ewwlinks +/"Case expressions" "http://learnyouahaskell.com/syntax-in-functions#case-expressions"
    ewwlinks +/"case, of" "https://wiki.haskell.org/Keywords#case.2C_of"

    These are equivalent:

        -- pattern matching
        head' :: [a] -> a
        head' [] = error "No head for empty lists!"
        head' (x:_) = x

        -- case expression
        head' :: [a] -> a
        head' xs = case xs of [] -> error "No head for empty lists!"
                              (x:_) -> x

sequence
sequence_
    ewwlinks +/"sequence \[(> 4), (< 10), odd\] 7" "http://derekwyatt.org/2012/01/25/haskell-sequence-over-functions-explained/"

    sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
    base Prelude

    Evaluate each monadic action in the
    structure from left to right, and collect
    the results. For a version that ignores
    the results see sequence_.

    sequence takes a list of I/O actions and
    returns an I/O actions that will perform
    those actions one after the other. The
    result contained in that I/O action will
    be a list of the results of all the I/O
    actions that were performed. Its type
    signature is sequence :: [IO a] -> IO [a].
    Doing this:

        main = do
            a <- getLine
            b <- getLine
            c <- getLine
            print [a,b,c]

    Is exactly the same as doing this:.

        main = do
            rs <- sequence [getLine, getLine, getLine]
            print rs

    A common pattern with sequence is when we
    map functions like print or putStrLn over
    lists. Doing map print [1,2,3,4] won't
    create an I/O action. It will create a
    list of I/O actions, because that's like
    writing [print 1, print 2, print 3, print
    4]. If we want to transform that list of
    I/O actions into an I/O action, we have to
    sequence it.

        ghci> sequence (map print [1,2,3,4,5])
        1
        2
        3
        4
        5
        [(),(),(),(),()]

    The sequence function takes a list of
    monadic computations, executes each one in
    turn and returns a list of the results.
    If any of the computations fail, then the
    whole function fails:

        sequence :: Monad m => [m a] -> m [a]
        sequence = foldr mcons (return [])
                     where mcons p q = p >>= \x -> q >>= \y -> return (x:y)

    The sequence_ function (notice the
    underscore) has the same behavior as
    sequence but does not return a list of
    results.  It is useful when only the
    side-effects of the monadic computations
    are important.

        sequence_ :: Monad m => [m a] -> m ()
        sequence_ = foldr (>>) (return ())

non-deterministic
    ewwlinks +/"Before looking at the source" "http://sleepomeno.github.io/blog/2014/06/25/Explaining-the-Magic/"

    But what sort of action is "01". As a
    string is a list of characters, it's equal
    to ['0','1'] which denotes a
    'non-deterministic' character value.

null
    null :: Foldable t => t a -> Bool
    base Prelude

    Test whether the structure is empty.

    The default implementation is optimized
    for structures that are similar to cons-
    lists, because there is no general way to
    do better.

replicateM
    I've seen replicateM shown as having both of these types.

    replicateM :: Monad m => Int -> m a -> m [a]
    replicateM :: Applicative m => Int -> m a -> m [a]
    base Control.Monad
    replicateM n act performs the action n times, gathering the results.

    eww "http://sleepomeno.github.io/blog/2014/06/25/Explaining-the-Magic/"

    Example

        replicateM 3 (putStrLn "hello")
        -- hello
        -- hello
        -- hello
        -- [(),(),()]

        replicateM 3 "01"
        -- ["000","001","010","011","100","101","110","111"]

    Explanation:
        But what sort of action is "01".  As a
        string is a list of characters, it's
        equal to ['0','1'] which denotes a
        'non-deterministic' character value.

    Old version is easier to understand
    http://hackage.haskell.org/package/base-4.7.0.0/docs/src/Control-Monad.html#replicateM
    http://hackage.haskell.org/package/base-4.12.0.0/docs/src/Control.Monad.html#replicateM

replicate
    replicate :: Int -> a -> [a]
    base Prelude

        hsdoc replicate

    replicate n x
        A list of length n with x the value of
        every element.

        It is an instance of the more general
        genericReplicate, in which n may be of any
        integral type.

elem
    elem :: (Foldable t, Eq a) => a -> t a -> Bool

    Does the element occur in the structure?

import qualified
    The module is imported 'qualified'.

    ewwlinks +/"11.1  Qualified Names" "https://www.haskell.org/tutorial/modules.html"

    This forces an obligatory namespace qualifier to imported identifiers.

    Examples
        import qualified Fringe ( fringe )

        import qualified TensorFlow.Core as TF

        ewwlinks +/"import qualified Mod" "https://wiki.haskell.org/Import"
        ewwlinks +/"import qualified Fringe ( fringe )" "https://www.haskell.org/tutorial/modules.html"

putStrLn
    putStrLn :: String -> IO ()
    base Prelude
    The same as putStr, but adds a newline character.

trace
    import Debug.Trace

    list = [1, 2, 3, 4, 5]

    main = do
        print list

        trace "print $ head list" print $ head list
        trace "print $ tail list" print $ tail list

    #haskell
        20:52 < libertyprime> hey guys. any way to simplify this to simply print out the expression and then execute it, to remove the repitition?
        20:53 < libertyprime> trace "print $ head list" print $ head list
        20:54 < Taneb> libertyprime: there isn't anything like that I'm afraid
        20:54 < solonarv> I suppose you could use template haskell and write something like: [traceQ| print $ head list |], but that seems like a very cumbersome and silly thing to do
        20:55 < solonarv> also, you're already working in IO (as indicated by the 'print'), why use trace at all?
        20:55 < solonarv> why not just: do putStrLn "print $ head list"; print $ head list
        20:56 < solonarv> then pick a more informative message and the repetition is also gone ;)
        20:58 < libertyprime> thanks guys. insightful. haha i should be flexing my racket skills to generate my haskell anyway
        20:59 < solonarv> o-O
        21:00 < solonarv> if you find yourself doing this a lot you could also write a helper function: printMsg msg val = putStrLn (msg ++ " = " ++ show val)

filter
    filter :: (a -> Bool) -> [a] -> [a]
    base Prelude
    filter, applied to a predicate and a list,
    returns the list of those elements that
    satisfy the predicate

    filter p xs = [ x | x <- xs, p x]

cycle
    print $ take 10 $ cycle [1..4]

    Ties a finite list into a circular one, or
    equivalently, the infinite repetition of
    the original list.

scanl
scanl :: (b -> a -> b) -> b -> [a] -> [b]
    Similar to foldl, but returns a list of
    successive reduced values from the left:

        scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]

scanr
scanr :: (a -> b -> b) -> b -> [a] -> [b]
    The right-to-left dual of scanl.

        head (scanr f z xs) == foldr f z xs.

scanr1
scanr1 :: (a -> a -> a) -> [a] -> [a]
    A variant of scanr that has no starting
    value argument.

list
[a]

[]
    A pattern that matches the empty list.

    It doesn't bind any variables.

    [] is also a type constructor. Given any
    type t we can "apply" [] to yield a new
    type [t]. The Haskell syntax allows [] t
    to be written as [t].

Foldable
    Own implementation:
        foldl :: (a -> b -> a) -> a -> [b] -> a

    From the standard library:
        foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

    The standard library uses 't a' instead of
    '[b]'.

    t stands for Foldable.
    Rather than a 'list of a', it's a 'Foldable of a'.

    class Foldable t
    base Prelude
    Data structures that can be folded.

    Example
        -- given a data type:

        data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)

        -- a suitable instance would be

        instance Foldable Tree where
        foldMap f Empty = mempty
        foldMap f (Leaf x) = f x
        foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r

    This is suitable even for abstract types,
    as the monoid is assumed to satisfy the
    monoid laws.

    Alternatively, one could define foldr:

        instance Foldable Tree where
        foldr f z Empty = z
        foldr f z (Leaf x) = f x z
        foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l

    Foldable instances are expected to satisfy
    the following laws:

        foldr f z t = appEndo (foldMap (Endo . f) t ) z

        foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z

        fold = foldMap id

        length = getSum . foldMap (Sum . const  1)

    sum, product, maximum, and minimum
    should all be essentially equivalent to foldMap forms, such
    as

    sum = getSum . foldMap Sum

    but may be less defined.

    If the type is also a Functor instance, it should satisfy

    foldMap f = fold . fmap f

    which implies that

    foldMap f . fmap g = foldMap (f . g)

(x:xs)
    [pattern]

    Matches a non-empty list which is formed
    by something (which gets bound to the x
    variable) which was cons'd (by the (:)
    function) onto something else (which gets
    bound to xs ).

    This doesn't look like a list, but it is.
    It's for pattern matching lists.
    Crazily, [x] here is not a list, but [a]
    is a list.

        fold :: (a -> a -> a) -> [a] -> a
        fold f [] = error "blah"
        fold f [x] = x
        fold f (x:xs) = f x (fold f x5)

predicate
(a -> Bool)

type
    ewwlinks +/"The type declaration is how one introduces an alias for an algebraic data type" "https://wiki.haskell.org/Keywords#type"

~
    https://wiki.haskell.org/Keywords#.7E

    - lazy pattern binding
      f2 x = case x of ~(Just n) -> "Got it"
    - type constraint
      example :: F a ~ b => a -> b

!
    Strictness flag.

    https://wiki.haskell.org/Keywords#.21

    Evaluate the argument (STList a), before passing to the constructor STCons.

    data STList a
            = STCons a !(STList a)  -- the second argument to STCons will be
                                    -- evaluated before STCons is applied
            | STNil

'
    https://wiki.haskell.org/Keywords#.27

    Used in:
    - Character literals: 'a'
    - Template Haskell:
      Name of a (value) variable or data constructor: 'length, 'Left
    - Promoted data constructor: 'True

''
    https://wiki.haskell.org/Keywords#.27.27

    [#Template Haskell]

    Name of a type constructor or class:
    - ''Int
    - ''Either
    - ''Show

- keyword
    [[https://wiki.haskell.org/Keywords#-][Keywords HaskellWiki -]]

    (- 1)

    is parsed as the negative integer -1,
    rather than as an operator

-- keyword
    [[https://wiki.haskell.org/Keywords#--][Keywords HaskellWiki --]]

    Starts a single-line comment, unless
    immediately followed by an operator
    character other than -:

    main = print "hello world" -- this is a comment
    --this is a comment as well
    ---this too
    foobar --+ this_is_the_second_argument_of_the_dash_dash_plus_operator

where
    https://wiki.haskell.org/Keywords#where

    Multiple uses:
    - introduce a module

      module Main where

    - introduce an instance

      instance Num Int  where
        ...

    - introduce a class

      class Num a where
        ...

    - introduce a GADT

      data Something a where
        ...

    - bind local variables:

      f x = y
          where y = x * 2

      g z | z > 2 = y
          where y = x * 2

      example:

        calcChange owed given = if change > 0
                   then change
                   else 0
                   where change = given - owed

arrow
arrow notation
    Arrows are a generalisation of monads.

    With the Arrows extension, GHC supports
    the arrow notation.

    ewwlinks +/"The extension adds a new kind of expression for defining arrows:" "http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#arrow-notation"

-<
    [[http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#arrow-notation][Arrow notation]]
    See "Generalising Monads to Arrows".

-<<
    [[http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#arrow-notation][Arrow notation]]
    See "Generalising Monads to Arrows".

category theory
    More general than abstract algebra.

monomorphic
monomorphism
    [#abstract algebra]
    [#universal algebra]

    An injective homomorphism.

    A monomorphism from X to Y is often
    denoted with the notation X โช Y.

monomorphic
monomorphism
monic morphism
mono
    [category theory]

    Left-cancellative morphism, that is, an
    arrow f : X โ Y such that, for all
    morphisms g1, g2 : Z โ X.

{-# LANGUAGE MultiParamTypeClasses #-}
    https://www.reddit.com/r/haskell/comments/a710ix/why_dependent_haskell_is_the_future_of_software/

{-# LANGUAGE DataKinds #-}
    https://www.reddit.com/r/haskell/comments/a710ix/why_dependent_haskell_is_the_future_of_software/

{-# LANGUAGE KindSignatures #-}
    https://www.reddit.com/r/haskell/comments/a710ix/why_dependent_haskell_is_the_future_of_software/

{-# LANGUAGE GADTs #-}
    https://www.reddit.com/r/haskell/comments/a710ix/why_dependent_haskell_is_the_future_of_software/

kind
    [#type theory]

    Could be:
    - The type of a type constructor.
    - The type of a higher-order type operator.

    A kind system is essentially a simply
    typed lambda calculus 'one level up,'
    endowed with a primitive type, denoted *
    and called 'type', which is the kind of
    any (monomorphic) data type."

    ewwlinks +/"Ordinary types, also called monotypes or nullary type constructors" "https://wiki.haskell.org/Kind"

        ghci> :kind (->)
        (->) :: * -> * -> *

//
    ewwlinks +/"13.4  Incremental updates" "https://www.haskell.org/tutorial/arrays.html"

    In addition to the monolithic array
    creation functions, Haskell also has an
    incremental array update function, written
    as the infix operator //; the simplest
    case, an array a with element i updated to
    v, is written a // [(i, v)].

    The reason for the square brackets is that
    the left argument of (//) is an
    association list, usually containing a
    proper subset of the indices of the array:

        (//) :: (Ix a) => Array a b -> [(a,b)] -> Array a b

    Monolithic:
        $MYGIT/acmeism/RosettaCodeData/Task/Arrays/Haskell/arrays.hs

keywords
    !                     	 https://wiki.haskell.org/Keywords#.21
    '                     	 https://wiki.haskell.org/Keywords#.27
    ''                    	 https://wiki.haskell.org/Keywords#.27.27
    -                     	 https://wiki.haskell.org/Keywords#-
    --                    	 https://wiki.haskell.org/Keywords#--
    -<                    	 https://wiki.haskell.org/Keywords#-.3C
    -<<                   	 https://wiki.haskell.org/Keywords#-.3C.3C
    ->                    	 https://wiki.haskell.org/Keywords#-.3E
    ::                    	 https://wiki.haskell.org/Keywords#
    ;                     	 https://wiki.haskell.org/Keywords#.3B
    <-                    	 https://wiki.haskell.org/Keywords#.3C-
    ,                     	 https://wiki.haskell.org/Keywords#.2C
    =                     	 https://wiki.haskell.org/Keywords#.3D
    =>                    	 https://wiki.haskell.org/Keywords#.3D.3E
    >                     	 https://wiki.haskell.org/Keywords#.3E
    ?                     	 https://wiki.haskell.org/Keywords#.3F
    #                     	 https://wiki.haskell.org/Keywords#.23
    *                     	 https://wiki.haskell.org/Keywords#.2A
    @                     	 https://wiki.haskell.org/Keywords#.40
    [|, |]                	 https://wiki.haskell.org/Keywords#.5B.7C.2C_.7C.5D
    \                     	 https://wiki.haskell.org/Keywords#.5C
    _                     	 https://wiki.haskell.org/Keywords#
    `                     	 https://wiki.haskell.org/Keywords#.60
    {, }                  	 https://wiki.haskell.org/Keywords#.7B.2C_.7D
    {-, -}                	 https://wiki.haskell.org/Keywords#.7B-.2C_-.7D
    |                     	 https://wiki.haskell.org/Keywords#.7C
    ~                     	 https://wiki.haskell.org/Keywords#.7E
    as                    	 https://wiki.haskell.org/Keywords#as
    case, of              	 https://wiki.haskell.org/Keywords#case.2C_of
    class                 	 https://wiki.haskell.org/Keywords#class
    data                  	 https://wiki.haskell.org/Keywords#data
    data family           	 https://wiki.haskell.org/Keywords#data_family
    data instance         	 https://wiki.haskell.org/Keywords#data_instance
    default               	 https://wiki.haskell.org/Keywords#default
    deriving              	 https://wiki.haskell.org/Keywords#deriving
    deriving instance     	 https://wiki.haskell.org/Keywords#deriving_instance
    do                    	 https://wiki.haskell.org/Keywords#do
    forall                	 https://wiki.haskell.org/Keywords#forall
    foreign               	 https://wiki.haskell.org/Keywords#foreign
    hiding                	 https://wiki.haskell.org/Keywords#hiding
    if, then, else        	 https://wiki.haskell.org/Keywords#if.2C_then.2C_else
    import                	 https://wiki.haskell.org/Keywords#import
    infix, infixl, infixr 	 https://wiki.haskell.org/Keywords#infix.2C_infixl.2C_infixr
    instance              	 https://wiki.haskell.org/Keywords#instance
    let, in               	 https://wiki.haskell.org/Keywords#let.2C_in
    mdo                   	 https://wiki.haskell.org/Keywords#mdo
    module                	 https://wiki.haskell.org/Keywords#module
    newtype               	 https://wiki.haskell.org/Keywords#newtype
    proc                  	 https://wiki.haskell.org/Keywords#proc
    qualified             	 https://wiki.haskell.org/Keywords#qualified
    rec                   	 https://wiki.haskell.org/Keywords#rec
    type                  	 https://wiki.haskell.org/Keywords#type
    type family           	 https://wiki.haskell.org/Keywords#type_family
    type instance         	 https://wiki.haskell.org/Keywords#type_instance
    where                 	 https://wiki.haskell.org/Keywords#where

deriving
    [keyword]

    ifl haskell deriving

        data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show)

    We won't concern ourselves with deriving
    too much for now.

    Let's just say that if we add deriving
    (Show) at the end of a data declaration,
    Haskell automagically makes that type part
    of the Show typeclass.

    So now, we can do this:

        ghci> Circle 10 20 5
        Circle 10.0 20.0 5.0
        ghci> Rectangle 50 230 60 90
        Rectangle 50.0 230.0 60.0 90.0

newtype
    [declaration]

    ewwlinks +/"A newtype declaration creates a new type in much the same way as data" "https://wiki.haskell.org/Newtype"

    Creates a new type in much the same way as
    data.

    How one introduces a renaming for an
    algebraic data type into Haskell.

    This is different from type below, as a
    newtype requires a new constructor as
    well.

    As an example, when writing a compiler one
    sometimes further qualifies Identifiers to
    assist in type safety checks:

        newtype SimpleIdentifier = SimpleIdentifier Identifier
        newtype FunctionIdentifier = FunctionIdentifier Identifier

    Most often, one supplies smart
    constructors and destructors for these to
    ease working with them.

    The syntax and usage of newtypes is
    virtually identical to that of data
    declarations - in fact, you can replace
    the newtype keyword with data and it'll
    still compile, indeed there's even a good
    chance your program will still work.

    The converse is not true, however - data
    can only be replaced with newtype if the
    type has exactly one constructor with
    exactly one field inside it.

the most basic haskell function usage
    -- Type annotation (optional, same for each implementation)
    factorial :: (Integral a) => a -> a

    -- Using a list and the "product" function
    factorial n = product [1..n]

fmap
liftM
liftM vs fmap
    Why do we have three different functions
    that do essentially the same thing?

        map :: (a -> b) -> [a] -> [b]
        fmap :: Functor f => (a -> b) -> f a -> f b
        liftM :: Monad m => (a -> b) -> m a -> m b

    fmap and liftM exist because monads were
    not automatically functors in Haskell.

    fmap and liftM are essentially
    interchangeable, since it is a bug (in a
    social rather than technical sense) for
    any type to be an instance of Monad
    without also being an instance of Functor.

where
    Where is like do, but contains declarations.

    $MYGIT/gwern/misc-haskell/d.hs

auto-installing dependencies
    How can I do this?

    vim +/"import System.Console.Readline" "$MYGIT/mklinik/haskell-misc/13/Main.hs"

recursion
    -- Type annotation (optional, same for each implementation)
    factorial :: (Integral a) => a -> a

    -- Using recursion (with the "ifthenelse" expression)
    factorial n = if n < 2
                  then 1
                  else n * factorial (n - 1)

    -- Using recursion (with pattern matching)
    factorial 0 = 1
    factorial n = n * factorial (n - 1)

    -- Using recursion (with guards)
    factorial n
       | n < 2     = 1
       | otherwise = n * factorial (n - 1)

length :: [a] -> Int
    recursive

    Multiple ways to solve
        length (_:xs) = 1 + length xs
        length = foldl (\a _ -> a + 1) 0

    vim +/"length :: \[a\] -> Int" "$MYGIT/google/haskell-trainings/haskell_101/codelab/Codelab.hs"

Template Haskell
TH
    [#haskell]
    [standard framework]

    type-safe, compile-time meta programming.

    Allows:
    - Writing Haskell meta programs, which are
      evaluated at compile-time, and which
      produce Haskell programs as the results
      of their execution.

    No non-Lisp language could ever hope to
    even stand in the shadow of how simple and
    powerful meta programming and extending
    your language is in a Lisp like Racket.

lazy evaluation
    Upside:
        It allows great reusability of code.

    Downside:
        Rather difficult to reason about time
        and space complexity.

map
    A ColorMap is a map from a Color to a Int.

    type ColorMap = Map Color Int

type alias
    -- An error message is just a String
    type ErrorMsg = String

type signature questions
    ifl many1 parsec

    #haskell.au
        16:26 < libertyprime> hey guys. im looking at this signature. * many1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m [a]    Quick question: Does this say that s,m
                              and t are all of the Stream monad type?
        16:27 < libertyprime> im total noob sorry. this will help me to understand
        16:40 < georgew> Stream is a multi-parameter typeclass, and Stream s m t is a constraint involving the type variables s m and t, which are used in the rest of the type
                         signature.
        16:41 < georgew> I believe this is an implementation detail of how Parsec handles input. I would approximate it in my head as `many1 :: Parsec a -> Parsec [a]`, for
                         some type alias Parsec that may not exist
        16:58 < libertyprime> georgew: thank you :) very helpful


    class (Monad m) =>
     Stream s m t | s -> t where
        uncons :: s -> m (Maybe (t,s))

unwords
    [function]

    hoogle -i unwords

    Inverse operation to words.

    It joins words with separating spaces.

    >>> unwords ["Lorem", "ipsum", "dolor"]
    "Lorem ipsum dolor"

dot composition
    https://stackoverflow.com/questions/631284/dot-operator-in-haskell-need-more-explanation

    vim +/"p = either print (putStrLn . unwords . map show) . parse tProg \"\"" "$MYGIT/acmeism/RosettaCodeData/Task/S-Expressions/Haskell/s-expressions.hs"

    f (g x) = (f . g) x

data vs newtype
    Most of the time, writing newtype whenever
    you can get away with it is a good idea.
    Maybe 1% of the time having access to the
    extra bottom denoted by data is absolutely
    critical.

    The reason they're different
        - newtype
          Indicates that the runtime
          representation of the value is
          identical to the underlying value.

        - data (with a single constructor and field)
          Will still have a wrapper box around
          the underlying value.

        A newtype around Int is going to be
        represented in memory in a way completely
        indistinguishable from an Int, while data
        X = X Int will have a box around it.

        This is particularly relevant when
        undefined is involved, or any other
        form of non-strictness.

        data
            data X = X Int
            foo = case undefined of
              X _ -> "This will error"

        newtype
            newtype Y = Y Int
            bar = case undefined of
              Y _ -> "This will not"

data
    Create a datatype to hold an abstract
    syntax tree for an expression, one could
    use:

    data Exp = Ebin   Operator Exp Exp
             | Eunary Operator Exp
             | Efun   FunctionIdentifier [Exp]
             | Eid    SimpleIdentifier

    where the types
    - Operator,
    - FunctionIdentifier, and
    - SimpleIdentifier
    are defined elsewhere.

    The types
    - Ebin
    - Eunary
    - Efun
    are all types of Exp

    Exp is partially recursive.
    An Ebin can hold 2 of Exp.

learn these language modifications
    cd $MYGIT/facebook/duckling/Duckling/; grep -HnR "# LANGUAGE" . | scrape "LANGUAGE [^ ]+" | uniqnosort

stack reinstall package
    Frustratingly none of this worked.
    rm -rf $HOME/.stack/programs/x86_64-linux/ghc8.6.3
    stack update
    stack install --force-dirty ghc-8.6.3

    But this did
    xmonad --recompile

    It started a stack install for me for ghc-8.6.3.

maybe
    https://www.snoyman.com/blog/2017/01/functors-applicatives-and-monads

    "lifts" or extends a type (e.g. Integer)
    into a new context in which it has an
    extra value (Nothing) that represents a
    lack of value!

    A more resilient way to write our code is
    to use the readMaybe function, which will
    return a Maybe Integer value. This makes
    it clear with the types themselves that
    the parse may succeed or fail. To test
    this out,

    try running the following code:

    #!/usr/bin/env stack
    -- stack --resolver lts-7.14 --install-ghc runghc
    import Text.Read (readMaybe)

    main = do
        -- We use explicit types to tell the compiler how to try and parse the
        -- string.
        print (readMaybe "1980" :: Maybe Integer)
        print (readMaybe "hello" :: Maybe Integer)
        print (readMaybe "2000" :: Maybe Integer)
        print (readMaybe "two-thousand" :: Maybe Integer)

read
    [function]

    https://www.snoyman.com/blog/2017/01/functors-applicatives-and-monads

    read is trying to parse it into an
    Integer. But not all Strings are valid
    Integers. read is what we call a partial
    function, meaning that under some
    circumstances it will return an error
    instead of a valid result.

strings
    String, ByteString, Lazy ByteString, Text, Lazy Text.

    - Ah, this regex package works on strings
      and I have Text.
    - This JSON library encodes to ByteString,
      and I need Text.
    - This url decoding implementation takes
      String as an input, and I have Text.
    - And so on and so forth.

    SOLUTION? string-conv
    https://hackage.haskell.org/package/string-conv-0.1

    string-conversions seems to be used more widely
    https://www.stackage.org/package/string-conversions

Get implemetation of function in haskell
    Unfortunately, the best way to find the
    implementation of some function is through
    this convoluted process

    http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List.html

    quick jump

    Alternatively, I can go on the #haskell.au
    IRC channel and type @src tail

    The website is 'hackage', but there is no
    easy link to 'quick jump'.

    http://hackage.haskell.org/

    I want to end up in a place link this.
    http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.List.html#tail

forM_
    mapM_ map lambda to list.
    Your every day map.

    The _ indicates ignore results.

    hsdoc forM_

    egr forM_

    Type:
    forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

    Type in context example:
    forM_ :: [Integer] -> (Integer -> IO ()) -> IO ()

    mapM_ with its arguments flipped.

forM_ vs forM
    forM_ function is more efficient than forM
    because it does not save the results of
    the operations.

    That is all.

forM_
    Ignores the results

forM
    Does not ignores the results.

    mapM with its arguments flipped.

mapM
    mapM mf xs takes a monadic function mf
    (having type Monad m => (a -> m b)) and
    applies it to each element in list xs; the
    result is a list inside a monad. The
    difference between mapM and mapM_ is, that
    mapM returns a list of the results, while
    mapM_ returns an empty result. The result
    of each action in mapM_ is not stored.

compose
.
(.)
function composition
    [operator]
    [infix operator]

        (.)                     :: (b->c) -> (a->b) -> (a->c)
        f . g                   = \ x -> f (g x)

convert functional value into infix operator
    Example:

        x `elem` xs

    This can be read intuitively as "x is an
    element of xs."

apply
$
($)
    [operator]

    low, right-associative binding precedence

    f $ g $ h x  =  f (g (h x))
    f (g $ h x)  =  f (g (h x))
    f (g (h x))  =  f (g (h x))

haskell guard
    I think what makes them special is that they calculate values which
    they use, later. ie. avg.
    Maybe not, though. I have no idea.

    https://www.youtube.com/watch?v=02_H3LjqMr8&list=PLGLfVvz_LVvSX7fVd4OUFp_ODd86H0ZIY&index=23

    batAvgRating :: Double -> Double -> String

    batAvgRating hits atBats
        | avg <= 0.200 = "Terrible Batting Average"
        | avg <= 0.250 = "Average Player"
        | avg <= 0.280 = "Your doing pretty good"
        | otherwise = "You're a Superstar"
        where avg = hits / atBats

comparing lists
    Can be compared if the stuff they contain
    can be compared.

    [3,2,1] > [2,1,0]
    [3,2,1] > [2,10,100]

!!
    "Steve Buscemi" !! 6

++
    [1,2,3,4] ++ [9,10,11,12]
    "hello" ++ " " ++ "world"
    ['w','o'] ++ ['o','t']
    'A':" SMALL CAT"
    ( [6,6,6]:[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] ++ [[1,1,1,1]] ) !! 2

let
    [ghci keyword]

    Note: We can use the let keyword to define
    a name right in GHCI.

    Doing let a = 1 inside GHCI is the
    equivalent of writing a = 1 in a script
    and then loading it.

    ghci> let lostNumbers = [4,8,15,16,23,42]
    ghci> lostNumbers
    [4,8,15,16,23,42]

'
    doubleSmallNumber' x = (if x > 100 then x else x*2) + 1

    The ' at the end of the function name.
    That apostrophe doesn't have any special
    meaning in Haskell's syntax. It's a valid
    character to use in a function name. We
    usually use ' to either denote a strict
    version of a function (one that isn't
    lazy) or a slightly modified version of a
    function or a variable. Because ' is a
    valid character in functions, we can make
    a function like this.

Typeclasses

Ord
    [typeclass]

    An instance of Ord is a thing that can be
    ordered.

AlGebraic Data Type
AgDT
    [#haskell]

    intro
        http://learnyouahaskell.com/making-our-own-types-and-typeclasses

ps@(p:pt)
    Syntactic sugar, with @ read aloud as "as". ps@(p:pt) gives you names for

    1. the list: ps
    2. the list's head : p
    3. the list's tail: pt
    Without the @, you'd have to choose between (1) or (2):(3).

    This syntax actually works for any
    constructor; if you have data Tree a =
    Tree a [Tree a], then t@(Tree _ kids)
    gives you access to both the tree and its
    children.

Redundant parentheses
    These are equal.
    A function takes 1 argument and returns a function.

    This is because it's right-associative.

    foldl :: (b -> a -> b) -> b -> [a] -> b
    foldl :: (b -> a -> b) -> (b -> [a] -> b)
    foldl :: (b -> (a -> b)) -> (b -> ([a] -> b))

arrow in return term in type declaration
    13:00 < libertyprime> 	 could somebody please explain to me the intuition behind why haskell uses -> for the return term in a type declaration?
    13:08 < dibblego>     	 there are a number of intuitions
    13:08 < dibblego>     	 e.g. A -> B, can be thought of as, "given A, a B can be produced"
    13:09 < dibblego>     	 it also corresponds to implication under a C-H logic correspondence. The proposition A implies B
    13:09 < dibblego>     	 importantly, it is right-associative
    13:09 < dibblego>     	 take the signature of foldl :: (b -> a -> b) -> b -> [a] -> b
    13:09 < dibblego>     	 I will now add redundant parentheses
    13:09 < dibblego>     	 foldl :: (b -> a -> b) -> (b -> [a] -> b)
    13:09 < dibblego>     	 and some more
    13:09 < dibblego>     	 foldl :: (b -> (a -> b)) -> (b -> ([a] -> b))
    13:10 < dibblego>     	 this goes to show, it takes one argument (and returns a function)
    13:54 < libertyprime> 	 thanks dibblego. ill meditate on this
    13:55 < dibblego>     	 no problem, here is a challenge, what is the type of this expression: foldl (++)

    ghcit $(p "foldl (++)")

    A -> B
        Can be thought of as, "given A, a B can be produced"

Find the type of an expression
    x -cd "$(pwd)" -sh "ghci" -e "Prelude>" -s ":t (+) 3" -c m -i

    ghci -v0 <<< ":t (+) 3" | v

ghci
    echo :browse Data.List | ghci | v

    # This is the cleaner way to do it
    ghci -v0 <<< ":browse Data.List" | v

chaining
    -- (++) is the concatenation operator
    -- to concatenate two linked lists you have to chain the second one
    -- at the end of the first one

    (++) :: [a] -> [a] -> [a]
    -- the definition of something with 2 parameters must have 2 params on
    -- the LHS
    []     ++ l2 = l2
    (l:l1) ++ l2 = l : (l1 ++ l2)
    -- l1 ++ l2 = foldr (:) l2 l1

Refactoring tips in emacs

     or :: [Bool] -> Bool
     or []     = False
     or (x:xs) = x || or xs
     -- or = foldl (||) False

    Use foldr
    Found:
      or [] = False
      or (x : xs) = x || or xs
    Perhaps:
      or xs = foldr (||) False xs

head:tail notation
    (l:l1) ++ l2 = l : (l1 ++ l2)

    Doesn't have to be x:xs

++
    vim +/"-- the definiton of something with 2 parameters must have 2 params on" "$MYGIT/google/haskell-trainings/haskell_101/codelab/Codelab.hs"

    []     ++ l2 = l2
    (l:l1) ++ l2 = l : (l1 ++ l2)
    -- l1 ++ l2 = foldr (:) l2 l1

and
    help hs and

    and = foldl (&&) True

    and []
    -- True

or
    or = foldl (||) True

    or []
    -- False

xs
    xs hs "foldl (/) 64 [4,2,4]"

lambda
    Instead of using equations to define
    functions, we can also define them
    "anonymously" via a lambda abstraction.

    For example, a function equivalent to inc
    could be written as \x -> x+1.

    Similarly, the function add is equivalent
    to \x -> \y -> x+y.

        xs hs "foldl (\x y -> 2*x + y) 4 [1,2,3]"

queryTerminal
    vim +/"import           System.Posix.Terminal (queryTerminal)" "$MYGIT/google/haskell-trainings/haskell_101/codelab/Main.hs"

    I can learn much from this file.

lambda
    unfoldr (\b -> fmap (const . (second $ drop 1) . break (==' ') $ b) . listToMaybe $ b)

    what comes directly after the \ are the input parameters.

String
[Char]
   String just a type alias for [Char]

   vim +/"type String = \[Char\]" "$(hoogle String | tf txt)"

error handling
    vim +/"head \[\]    = error \"head: empty list\" -- \[\], therefore error" "$MYGIT/google/haskell-trainings/haskell_101/codelab/Codelab.hs"

type signatures
    -- these are the same
    head :: [h] -> h
    head :: [a] -> a

    -- this is not the same type
    head :: [a] -> h

{-# Language TypeFamilies #-}
Indexed type families
type families (for short)
    [Haskell extension]

    For supporting ad-hoc overloading of data
    types.

    Type families are parametric types that
    can be assigned specialized
    representations based on the type
    parameters they are instantiated with.

    They are the data type analogue of type
    classes: families are used to define
    overloaded data in the same way that
    classes are used to define overloaded
    functions.

    Type families are useful for generic
    programming, for creating highly
    parameterised library interfaces, and for
    creating interfaces with enhanced static
    information, much like dependent types.

    Come in two flavors:
    - data families
    - type synonym families

    Data families
        The indexed form of data and newtype
        definitions.

    Type synonym families
        The indexed form of type synonyms.

    Each of these flavors can be defined in a
    standalone manner or associated with a
    type class.

    Standalone definitions are more general,
    while associated types can more clearly
    express how a type is used and lead to
    better error messages.

{-# LANGUAGE CPP #-}
    .hs files will be processed with C preprocessor before the code is compiled.

{-# LANGUAGE QuasiQuotes #-}
    ewwlinks +/"tutorial for the quasiquoting facility" "https://wiki.haskell.org/Quasiquotation"

    Quasiquoting allows programmers to use
    custom, domain-specific syntax to
    construct fragments of their program.

    Along with Haskell's existing support for
    domain specific languages, you are now
    free to use new syntactic forms for your
    EDSLs.

monads, Foldable
    foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

    Is Foldable a monad?
    No it's not. Though the type signaturee makes it look likee it is.
    I think "Foldable t =>" just says what something is.

fold
Foldable
    import Data.Foldable

    Foldable provides you with fold.

    You can use fold to combine a list of
    monoids/foldable things into a single
    monoid/foldable thing.

    For example, after turning a list of
    strings into a list of builders, and the
    builders are foldable, you can then fold
    them all into eachother to produce a
    single foldable.

    https://youtu.be/FYTZkE5BZ-0?t=265

foldl
    https://youtu.be/24XK4LPoCXc?t=89

    help hs foldl

    xs hs "foldl (/) 64 [4,2,4]"

    reduces the list using the binary operator, from left to right:

    -- this was a custom implementation
    length = foldl (\a _ -> a + 1) 0

    Prelude foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

    Takes a function
        (b -> a -> b)
    and a value
        b
    and a value of type Foldable
        t a
    and returns a value
        b

    xs hs "foldl max 5 [1,2,3,4,5,6,7]"

    x -cd "$(pwd)" -sh "ghci" -e "Prelude>" -s "a = foldl (\xs y -> 10*xs -y) 0" -c m -e "Prelude>" -s "a [1,2,3]" -c m -i

foldr
    https://youtu.be/24XK4LPoCXc?t=89

fold
unfold
    https://kseo.github.io/posts/2016-12-12-unfold-and-fold.html

    Every functional programmer loves fold.
    fold is universal and expressive. But fold
    has a secret twin brother named unfold
    which undoes what fold does.

    unfoldr builds a list from a seed value
    while foldr reduces a list to a summary
    value.

Control.Applicative
    A structure intermediate between a functor
    and a monad (technically, a strong lax
    monoidal functor). Compared with monads,
    this interface lacks the full power of the
    binding operation >>=, but:
    - it has more instances.
    - it is sufficient for many uses, e.g.
      context-free parsing, or the Traversable
      class.
    - instances can perform analysis of
      computations before they are executed,
      and thus produce shared optimizations.

    See also:
        vim +/"Applicative vs Normal Order" "$HOME/notes/glossary.txt"

ApplicativeDo
    https://gitlab.haskell.org/ghc/ghc/wikis/applicative-do

    Adds support to GHC for desugaring
    do-notation into Applicative expressions
    where possible.

    When ApplicativeDo is turned on, GHC will
    use a different method for desugaring
    do-notation, which attempts to use the
    Applicative operator <*> as far as
    possible, along with fmap and join.

Abstract Data Type
AbDT (to differentiate)
ADT
    [#haskell]

    ewwlinks +/"11.2  Abstract Data Types" "https://www.haskell.org/tutorial/modules.html"

    Must create a module to create new AbDTs.

        module TreeADT (Tree, leaf, branch, cell,
                        left, right, isLeaf) where

        data Tree a             = Leaf a | Branch (Tree a) (Tree a)

        leaf                    = Leaf
        branch                  = Branch
        cell  (Leaf a)          = a
        left  (Branch l r)      = l
        right (Branch l r)      = r
        isLeaf   (Leaf _)       = True
        isLeaf   _              = False

    vim +/"Abstract Data Type" "$HOME/notes/glossary.txt"

module
    A Haskell program consists of a collection
    of modules.

    A module in Haskell serves the dual
    purpose of:
    - controlling name-spaces
    - creating abstract data types.

    Module names are alphanumeric and must
    begin with an uppercase letter.

    Export list:
        ( Tree(Leaf,Branch), fringe )
        https://www.haskell.org/tutorial/modules.html

    Modules provide the only way to build
    AbDTs in Haskell.

atomically
    [#haskell]

    $MYGIT/lotz84/haskellbyexample/ex/atomic-counters.md.hs

co-monad
comonad
    ewwlinks +/"Control.Monad.Co" "http://hackage.haskell.org/package/kan-extensions-5.2/docs/Control-Monad-Co.html"

thunk build-up
    ewwlinks +/"Note that iterate is lazy, potentially leading to thunk build-up if the consumer doesn't force each iterate." "http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-OldList.html#v:iterate"

thunk
    A value that is yet to be evaluated.

    https://wiki.haskell.org/Thunk

array
    ewwlinks +/"13  Arrays" "https://www.haskell.org/tutorial/arrays.html"

    ewwlinks +/"array #" "http://hackage.haskell.org/package/array-0.5.3.0/docs/Data-Array.html#v:array"

    hs-browse Data.Array

    Not part of the Standard Prelude.

Existential types
existentials
    A way of 'squashing' a group of types into
    one, single type.

universal quantification
universally quantified

forall
    IORef :: forall t. t

    Can be any type

forall
    In standard Haskell 98/2010 type variables
    in a type expression are all assumed to be
    universally quantified.

    Example
        The type expression
            a -> a
        denotes the type
            forall a. a ->a~

    ewwlinks +/"The forall keyword" "https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types"

    The scope of the forall extends as far to
    the right as possible; for example,

        forall a. a -> a

    means

        forall a. (a -> a)

    Examples:
        head :: [a] -> a
        head []    = error "head: empty list"
        head (x:_) = x
        -- a :: forall t. t
        -- x: :: forall a. a -> [a] -> [a]
        -- : :: forall a. a -> [a] -> [a]
        -- _ :: [a]

        isNothing :: Maybe a -> Bool
        isNothing Nothing  = True
        isNothing (Just _) = False
        -- a :: forall t. t
        -- Just :: forall a. a -> Maybe a
        -- _ :: a
        -- Nothing :: forall a. Maybe a
        -- isNothing :: forall a. Maybe a -> Bool

hiding
    When importing modules, without
    introducing a name into scope, entities
    can be excluded by using the form

        hiding (import1 , ... , importn )

    which specifies that all entities exported
    by the named module should be imported
    except for those named in the list.

    For example:

        import Prelude hiding (lookup,filter,foldr,foldl,null,map)

polymorphic function
    ewwlinks +/"Example: A polymorphic function" "https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types"

    A and b are type variables.

        map :: (a -> b) -> [a] -> [b]

    The compiler sees that they begin with a
    lowercase letter and as such allows any
    type to fill that role.

    Another way of putting this is that those
    variables are 'universally quantified'.

imperative programming
    It is possible to write imperative-style
    code in Haskell as well.

    Sometimes we really do want to say
    something like "do A, then do B, then do
    C".

    This adds a new dimension to the simple
    world of function application: we need a
    notion of 'happens before'.

    Haskell has embraced the Monad concept to
    describe computations that have an order
    of evaluation.

    This turns out to be very handy because it
    can encapsulate effects such as changing
    state.

//
    hoogle //

    (//) :: Vector a -> [(Int, a)] -> Vector a
    vector Data.Vector
    O(m+n) For each pair (i,a) from the list, replace the



    vector element at position i by a.

!
    2 forms:
    - in a haskell type declaration
    - as an operator in an expression

    Declaration:
        It's a strictness declaration.
        Basically, it means that it must be
        evaluated to what's called "weak
        normal head form" when the data
        structure value is created.

            data MidiMessage = MidiMessage !Int !MidiMessage

    Operator:
        The value at the given index in an array.

            (!) :: IntMap a -> Key -> a

        containers Data.IntMap.Internal
        O(min(n,W)). Find the value at a key. Calls error when
        the element can not be found.

            fromList [(5,'a'), (3,'b')] ! 1
            -- Error: element not in the map

            fromList [(5,'a'), (3,'b')] ! 5 == 'a'

forever
    hsdoc forever

    Repeat an action indefinitely.

        forever :: Applicative f => f a -> f b Source #

reverse binder function
=<<
(=<<)
    (=<<) :: Monad m => (a -> m b) -> m a -> m b
    base Prelude
    Same as >>=, but with the arguments interchanged.

    These are equivalent:

        print =<< nextInt
        nextInt >>= print

    The prelude also defines a binding function that takes it arguments in the opposite order to
    the standard binding function. Since the standard binding function is called ">>=", the
    reverse binding function is called "=<<". It is useful in circumstances where the binding
    operator is used as a higher-order term and it is more convenient to have the arguments in the
    reversed order. Its definition is simply:

        (=<<) :: Monad m => (a -> m b) -> m a -> m b
        f =<< x = x >>= f

    >>= vs =<<

        Prelude> :t (>>=)
        (>>=) :: Monad m => m a -> (a -> m b) -> m b
        Prelude> :t (=<<)
        (=<<) :: Monad m => (a -> m b) -> m a -> m b

type-declarative search

    I can do type-declarative search with
    hoogle. I don't need to use the IRC bot

        stack exec -- hoogle "(a -> b) -> [a] -> [b]"

bracket
    vim +/"bracket (openBinaryFile \"\/tmp\/dat2\" WriteMode)" "$MYGIT/lotz84/haskellbyexample/ex/writing-files.md.hs"

    bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c

    base Control.Exception

    When you want to acquire a resource, do some work with it, and then
    release the resource, it is a good idea to use bracket, because
    bracket will install the necessary exception handler to release
    the resource in the event that an exception is raised during the
    computation. If an exception is raised, then bracket will
    re-raise the exception (after performing the release).

ghcup
    An installer for the general purpose
    language Haskell.

Ix
    http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ix.html

    The Ix class is used to map a contiguous
    subrange of values in type onto integers.

    It is used primarily for array indexing
    (see the array package).

    Ix uses row-major order.

        hsdoc Ix

        >let a = array (0, 4) [(i, 0) | i <- [0..4]]
        >:t a
        (Ix i, Enum i, Num i, Num e) => Array i e
        Array Integer Integer

Parsec
    An industrial strength, monadic parser
    combinator library for Haskell.

    It can parse context-sensitive, infinite
    look-ahead grammars but it performs best
    on predictive (LL[1]) grammars.

apostrophe
    In an identifier name:
        Just part of the name.

        It is a naming convention (idiom)
        adopted in Haskell.

        The convention in Haskell is that,
        like in math, the apostrophe on a
        variable name represents a variable
        that is somehow related, or similar,
        to a prior variable.

        x' is related to x , and we indicate
        that with the apostrophe.

lazy IO

containers
    vim +/"Haskell containers" "$NOTES/ws/haskell/remember.org"

finite map
dictionary
    http://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html

hpack
    hpack: A modern format for Haskell packages

    Hpack is a format for Haskell packages. It
    is a modern alternative to the Cabal
    package format and follows different
    design principles.

type synonym
    https://wiki.haskell.org/Type_synonym

    A type synonym is a new name for an
    existing type. Values of different
    synonyms of the same type are entirely
    compatible. In Haskell you can define a
    type synonym using type:

    type MyChar = Char

    In C you define a type synonym using
    typedef.

type vs data vs newtype
    The 'data' keyword allows you to
    introduce a new algebraic data type, while
    'type' just makes a type synonym.

    =newtype= is like =data= in that they both
    create algebraic data types, where =type=
    only creates a type synonym.

    =newtype= is like =type= in that you may
    only have one value constructor.

value parameter
    Value constructors can take value
    parameters produce a new value.

    Just a
        data Maybe a = Nothing | Just a

type parameter
    Type constructors can take types as
    parameters to produce new types.

    Maybe a
        data Maybe a = Nothing | Just a

parameterized type
    https://livebook.manning.com/book/get-programming-with-haskell/chapter-18/

Unit type
    https://en.wikipedia.org/wiki/Unit_type

    v +/"\*\* Unit type" "$HOME/blog/posts/haskell-typeclasses.org"

staging programs
    Writing programs using template haskell.

stage polymorphic programs

typed template haskell
    All about generating expressions in a
    principled manner.

TypeApplications
Type Application
    [language extension]

    ewwlinks +/"Type Application" "https://gitlab.haskell.org/ghc/ghc/-/wikis/type-application"

    answer_read = show (read @Int "3") -- "3" :: String
    answer_show = show @Integer (read "5") -- "5" :: String
    answer_showread = show @Int (read @Int "7") -- "7" :: String

floatLE
    floatLE :: Float -> Builder

    bytestring Data.ByteString.Builder
    Encode a Float in little endian format.

runCommand
    This is how I need to invoke commands in
    haskell.

    runCommand $ printf "/bin/bash -c \"export SHELL=bash; source ~/.profile || :; sps cava; ffplay -autoexit -showmode 0 -f f32le -ar %f %s\"; killall cava" sampleRate outputFilePath

_
    The underscore `_` is used as a "*don't
    care*" variable.

error
    https://youtu.be/24XK4LPoCXc?t=124

<$>
fmap
    https://youtu.be/xCut-QT2cpI?t=364

    An infix synonym for fmap. The name of
    this operator is an allusion to $. Note
    the similarities between their types:

    ($)  ::              (a -> b) ->   a ->   b
    (<$>) :: Functor f => (a -> b) -> f a -> f b
    Whereas $ is function application, <$> is function application lifted over a Functor.

    Examples

    Convert from a Maybe Int to a Maybe String using show:

    >>> show <$> Nothing
    Nothing

    >>> show <$> Just 3
    Just "3"
    Convert from an Either Int Int to an Either Int String using show:

    >>> show <$> Left 17
    Left 17

    >>> show <$> Right 17
    Right "17"
    Double each element of a list:

    >>> (*2) <$> [1,2,3]
    [2,4,6]
    Apply even to the second element of a pair:

    >>> even <$> (2,2)
    (2,True)

    https://hoogle.haskell.org/?hoogle=%3C%24%3E&scope=set%3Astackage

layout keywords
    - let
    - where
    - of
    - do

    https://en.wikibooks.org/wiki/Haskell/Indentation#:~:text=Haskell%20relies%20on%20indentation%20to,a%20couple%20fundamental%20layout%20rules.

_value namespace_
_type namespace_
    There are two completely separate
    namespaces in any Haskell source file:
    - The value namespace, and
    - the type namespace.

    The former is where functions, literals,
    patterns, etc. reside, and the latter is
    where you'll find type constructors,
    typeclasses, and type variables.

::
(::)
has type operator
    [operator]

    The stuff on the left of the operator is
    in the value namespace, and the stuff on
    the right is in the type namespace, as in
    5 :: Int.

NamedFieldPuns
    https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#record-puns

    When using records, it is common to write
    a pattern that binds a variable with the
    same name as a record field, such as:

        data C = C {a :: Int}
        f (C {a = a}) = a

    Record punning permits the variable name
    to be elided, so one can simply write

        f (C {a}) = a

    to mean the same pattern as above. That
    is, in a record pattern, the pattern a
    expands into the pattern a = a for the
    same name a.

lambda calculus
ฮป calculus
    A formal system in mathematical logic for
    expressing computation based on function
    abstraction and application using variable
    binding and substitution.

    It is a universal model of computation
    that can be used to simulate any Turing
    machine.

    It was introduced by the mathematician
    Alonzo Church in the 1930s as part of his
    research into the foundations of
    mathematics.

beta reduction
ฮฒ reduction
    [lambda calculus]

    The process of calculating a result from
    the application of a function to an
    expression.

cradle
    [#hie]
    [#hie.yaml]

    https://www.stackage.org/haddock/nightly-2021-02-05/hie-bios-0.7.2/HIE-Bios-Cradle.html

HIE Bios
hie-bios
    [#hie]

    Provides an abstraction over the GHC Api
    to initialise a GHC session and loading
    modules in a project.

    Defines the `hie.yaml` file specification.
    This is used to explicitly configure how a
    project should be built by GHC.

hie.yaml
    [#hie]
    [specification]

    Used to explicitly configure how a project
    should be built by GHC.

    https://www.reddit.com/r/haskell/comments/hcu5sf/mystified_by_hieyaml/

>>=
>>
bind
    The >>= function is known as "bind"
    because it binds the value in a monad
    container to the first argument of a
    function.

    One of the operators of Monad; Another is
    'return', which is rather simple, it just
    containerizes a value.

    (>>) and (>>=) are both bind variants.

    Explanation of (>>):
        https://youtu.be/_Gk_lwhJMzk?t=278

    infixl 1  >>, >>=
    class  Monad m  where
        (>>=)            :: m a -> (a -> m b) -> m b
        (>>)             :: m a -> m b -> m b
        return           :: a -> m a
        fail             :: String -> m a

        m >> k           =  m >>= \_ -> k

MINIMAL
    The MINIMAL comment here means that
    there is only one function that we need in
    order to have a Monad, (>>=), the bind
    operator.

      ghciol ":i Monad"

      {-# MINIMAL (>>=) #-}

instance
    This output also shows that Maybe and IO
    are instances of Monad.

      ghciol ":i Monad"

      instance Monad Maybe -- Defined in 'GHC.Base'
      instance Monad IO -- Defined in 'GHC.Base'

    https://youtu.be/CNOff5LPKQI?t=369

mod
modulo
    [operator]

    Like 'rem', but after modular division.

div
    [operator]

    Integral division, round down.

    (div x y)*y + (mod x y) == x

quot
quotient
    [operator]

    Integral division, round towards zero.

    (quot x y)*y + (rem x y) == x

rem
remainder
    [operator]

    Remainder after division.

QualifiedDo
    https://www.tweag.io/blog/2020-07-13-qualified-do-announcement/
    https://www.youtube.com/watch?v=TH3cYp3349A

LiftIO
    https://www.schoolofhaskell.com/user/commercial/content/monad-transformers

sequenceA
    https://www.youtube.com/watch?v=N9RUqGYuGfw&t=1347s&ab_channel=Tsoding

as-pattern
@
    ewwlinks +/"^As-patterns." "http://www.cs.otago.ac.nz/coursework/cosc347/References/FP/haskell-98-tutorial-html/patterns.html"

    The @ Symbol is used to both give a name
    to a parameter and match that parameter
    against a pattern that follows the @.

    It's not specific to lists and can also be
    used with other data structures.

    It's just syntactic sugar, with @ read
    aloud as "as".

    Example:
        f (x:xs)                = x:x:xs

    can be rewritten as:
        f s@(x:xs)             = x:s

    Example:
        fib@(1:tfib)    = 1 : 1 : [ a+b | (a,b) <- zip fib tfib ]

    Example:
        ps@(p:pt)
    gives you names for:
        the list: ps
        the list's head : p
        the list's tail: pt

    Without the @, you'd have to choose
    between (1) or (2):(3).

    This syntax actually works for any
    constructor; if you have data Tree a =
    Tree a [Tree a], then t@(Tree _ kids)
    gives you access to both the tree and its
    children.

wrapped value
    Example:
        Just 9

    9 is wrapped in a Just.

    Can't do:
        (+3) (Just 9)

        That's where the functor comes into
        play.

        fmap (+3) (Just 4) -> Just 7

unwrapped value
    Example:
        9

->
(->)
    ghcd "(->)"

if
else
    The else part is mandatory in Haskell.

    doubleSmallNumber x = if x > 100
                            then x
                            else x*2

    vs case:

        if e1then e2else e3

    which is really short-hand for: 

        case e1 of True  -> e2  
                   False -> e3  

Constraint
    ewwlinks +/"The following things" "https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/constraint_kind.html"

    Among others:
        Anything whose form is not yet known,
        but the user has declared to have kind
        Constraint (for which they need to
        import it from Data.Kind )

    ghcd 5.5
    ghcd Fractional

Yesod
main = warp 3000
    web framework

    main = warp 3000

    eww "https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/Simple%20examples"

total function
    sp +/"total functions" "$HOME/Calibre Library/Jan Stolarek/Understanding Basic Haskell Error Messages (90)/Understanding Basic Haskell Error Messages - Jan Stolarek.txt"

    Safe version of head function which will
    work for all possible inputs without
    throwing an exception.

applicative expression
    NLG: A function is called an applicative
    expression if it is either a constant or a
    function of exactly one argument

    NLG: An expression that is syntactically
    valid Haskell code, but the fixity or
    syntax of which is not valid Haskell.

    For example, `1 + (2 * 3)` would be an
    applicative expression

type-level programming
    ewwlinks +/"^Type-level programming" "https://rebeccaskinner.net/posts/2021-08-25-introduction-to-type-level-programming.html"

    NLG: "Type-level programming" is a
    programming paradigm in which the types of
    data are used to guide and inform the
    design of programs.

newtype wrapper
    https://hackage.haskell.org/package/newtype-zoo

    ewwlinks +/"^The simplest way to define" "https://rebeccaskinner.net/posts/2021-08-25-introduction-to-type-level-programming.html"

    NLG: A datatype that wraps an existing
    Haskell datatype, such that it is defined
    with a constructor that ensures that the
    datatype is in fact new.

    NLG: Haskell's newtype wrapper allows you
    to generate new datatypes with type safety
    enforced.

ST monad
    The monadic ST type provides support for
    strict state threads.

====
    Identity.

    See "The three fundamental laws of monads".

MonadPlus
zero
plus
mzero
mplus
    Beyond the three monad laws, some monads
    obey additional laws. These monads have a
    special value mzero and an operator mplus
    that obey four additional laws:

        1 mzero >>= f == mzero
        2 m >>= (\x -> mzero) == mzero
        3 mzero `mplus` m == m
        4 m `mplus` mzero == m

    It is easy to remember the laws for mzero
    and mplus if you associate mzero with 0,
    mplus with +, and >>= with ร in ordinary
    arithmetic.

    Monads which have a zero and a plus can be
    declared as instances of the MonadPlus
    class in Haskell:

        class (Monad m) => MonadPlus m where
            mzero :: m a
            mplus :: m a -> m a -> m a

    Continuing to use the Maybe monad as an
    example, we see that the Maybe monad is an
    instance of MonadPlus:

        instance MonadPlus Maybe where
            mzero             = Nothing
            Nothing `mplus` x = x
            x `mplus` _       = x

FiniteMap
    ewwlinks +/"FiniteMap" "https://wiki.haskell.org/All_About_Monads"

principal
principal type
    An expression's or function's principal
    type is the least general type that,
    intuitively, "contains all instances of
    the expression".
    
    For example, the principal type of head is
    [a]->a; [b]->a, a->a, or even a are
    correct types, but too general, whereas
    something like [Integer]->Integer is too
    specific.

nullary constructor
    If a constructor does not take any data
    arguments, it is nullary. 

enumerated type
    Examples:
        data Bool  = False | True
        data Color = Red | Green | Blue | Indigo | Violet

    Both Bool and Color are examples of
    enumerated types, since they consist of a
    finite number of nullary data
    constructors.

tuple type
    Example:
        data Point a = Pt a a

    Because of the single constructor, a type
    like Point is often called a tuple type,
    since it is essentially just a cartesian
    product (in this case binary) of other
    types. (Tuples are somewhat like records
    in other languages.)

multi-constructor type
union type
sum types
    In contrast to tuple types,
    multi-constructor types, such as Bool and
    Color (See enumerated type), are called
    (disjoint) union or sum types.

polymorphic type
    Example:
        data Point a = Pt a a

    For any type t, Point defines the type of
    cartesian points that use t as the
    coordinate type.

unary type constructor
    Example:
        data Point a = Pt a a

    The Point type can now be seen clearly as
    a unary type constructor, since from the
    type t it constructs a new type Point t.

binary data constructor
    Example:
        Pt is a -> a -> Point a,

    Thus the following typings are valid: 
        Pt  2.0  3.0            :: Point Float
        Pt  'a'  'b'            :: Point Char
        Pt True False           :: Point Bool

recursive type
    Examples
        -- binary trees
        data Tree a = Leaf a | Branch (Tree a) (Tree a) 

race
    Allows you to kill asynchonous exceptions
    from the outside.

    https://youtu.be/DebDaiYev2M?t=596

atomic type
    Examples:
    - Integer (infinite-precision integers),
    - Char (characters),
    - Integer->Integer (functions mapping Integer to Integer)

structured type
    Examples:
    - [Integer] (homogeneous lists of integers)
    - (Char,Integer) (character, integer pairs).

typing
    [declaration]

    The association of a value with its type.

    Examples:
             5  :: Integer
            'a' :: Char
            inc :: Integer -> Integer
        [1,2,3] :: [Integer]
        ('b',4) :: (Char,Integer)

equation
    [declaration]

    Functions in Haskell are normally defined
    by a series of equations.

    For example, the function inc can be
    defined by the single equation: 

        inc n = n+1

type signature declaration
    [declaration]

    We can declare an explicit typing for inc: 

        inc :: Integer -> Integer

lazy pattern
    ewwlinks +/"4.4  Lazy Patterns" "http://www.cs.otago.ac.nz/coursework/cosc347/References/FP/haskell-98-tutorial-html/patterns.html"

    There is one other kind of pattern allowed
    in Haskell.
    
    It is called a lazy pattern, and has the
    form ~pat.
    
    Lazy patterns are irrefutable: matching a
    value v against ~pat always succeeds,
    regardless of pat.
    
    Operationally speaking, if an identifier
    in pat is later "used" on the right-hand-
    side, it will be bound to that portion of
    the value that would result if v were to
    successfully match pat, and _|_ otherwise.
    
    Lazy patterns are useful in contexts where
    infinite data structures are being defined
    recursively.
    
    For example, infinite lists are an
    excellent vehicle for writing simulation
    programs, and in this context the infinite
    lists are often called streams.
    
    Consider the simple case of simulating the
    interactions between a server process
    server and a client process client, where
    client sends a sequence of requests to
    server, and server replies to each request
    with some kind of response.
    
    This situation is shown pictorially in
    Figure 2.
    
    (Note that client also takes an initial
    message as argument.)

    Client Server Example 

    Using streams to simulate the message
    sequences, the Haskell code corresponding
    to this diagram is: 

        reqs  = client init resps
        resps = server reqs

    These recursive equations are a direct
    lexical transliteration of the diagram.

    Let us further assume that the structure
    of the server and client look something
    like this: 

        client init (resp:resps) = init : client (next resp) resps
        server      (req:reqs)   = process req : server reqs

    where we assume that next is a function
    that, given a response from the server,
    determines the next request, and process
    is a function that processes a request
    from the client, returning an appropriate
    response.

    Unfortunately, this program has a serious
    problem: it will not produce any output!
    The problem is that client, as used in the
    recursive setting of reqs and resps,
    attempts a match on the response list
    before it has submitted its first request!
    In other words, the pattern matching is
    being done "too early." One way to fix
    this is to redefine client as follows: 

        client init resps = init : client (next (head resps)) (tail resps)

    Although workable, this solution does not
    read as well as that given earlier. A
    better solution is to use a lazy pattern:

        client init ~(resp:resps) = init : client (next resp) resps

    Because lazy patterns are irrefutable, the
    match will immediately succeed, allowing
    the initial request to be "submitted", in
    turn allowing the first response to be
    generated; the engine is now "primed", and
    the recursion takes care of the rest.

pattern binding
    [lazy binding]

    As another example of the use of lazy
    patterns, consider the definition of
    Fibonacci given earlier: 

    fib             = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]

    We might try rewriting this using an as-pattern: 

    fib@(1:tfib)    = 1 : 1 : [ a+b | (a,b) <- zip fib tfib ]

    This version of fib has the (small)
    advantage of not using tail on the
    right-hand side, since it is available in
    "destructured" form on the left-hand side
    as tfib.

    This kind of equation is called a pattern
    binding because it is a top-level equation
    in which the entire left-hand side is a
    pattern; i.e. both fib and tfib become
    bound within the scope of the
    declaration.

    Now, using the same reasoning as earlier,
    we should be led to believe that this
    program will not generate any output.
    Curiously, however, it does, and the
    reason is simple: in Haskell, pattern
    bindings are assumed to have an implicit ~
    in front of them, reflecting the most
    common behavior expected of pattern
    bindings, and avoiding some anomalous
    situations which are beyond the scope of
    this tutorial. Thus we see that lazy
    patterns play an important role in
    Haskell, if only implicitly. 

block-structuring
    [form]

    Examples:
    - let expressions
    - where clauses

let
Let expression
    Haskell's let expressions are useful
    whenever a nested set of bindings is
    required. As a simple example, consider: 

        let y   = a*b
            f x = (x+y)/y
        in f c + f d

    The set of bindings created by a let
    expression is mutually recursive, and
    pattern bindings are treated as lazy
    patterns (i.e. they carry an implicit ~).
    The only kind of declarations permitted
    are type signatures, function bindings,
    and pattern bindings.

mutually recursive

where
where clause
    Sometimes it is convenient to scope
    bindings over several guarded equations,
    which requires a where clause: 

        f x y  |  y>z           =  ...
               |  y==z          =  ...
               |  y<z           =  ...
             where z = x*x

    Note that this cannot be done with a let
    expression, which only scopes over the
    expression which it encloses. A where
    clause is only allowed at the top level of
    a set of equations or case expression. The
    same properties and constraints on
    bindings in let expressions apply to those
    in where clauses.

let vs where
    These two forms of nested scope seem very
    similar, but remember that a let
    expression is an expression, whereas a
    where clause is not---it is part of the
    syntax of function declarations and case
    expressions. 